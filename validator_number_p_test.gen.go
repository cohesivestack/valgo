// Code generated by Valgo; DO NOT EDIT.

package valgo

import (
	"testing"

	"github.com/stretchr/testify/assert"
)



func TestValidatorUint8PNot(t *testing.T) {
	ResetMessages()

	number1 := uint8(2)

	v := Is(Uint8P(&number1).Not().EqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorUint8PEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint8(2)

	v = Is(Uint8P(&number1).EqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint8P(&myNumber1).EqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint8PEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint8(2)
	number1 := &_number1

	v = Is(Uint8P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint8P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Uint8P(&myNumber1).EqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint8PGreaterThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint8(3)

	v = Is(Uint8P(&number1).GreaterThan(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Uint8P(&myNumber1).GreaterThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorUint8PGreaterThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint8(2)
	number1 := &_number1

	v = Is(Uint8P(number1).GreaterThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = 2

	v = Is(Uint8P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint8P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint8P(&myNumber1).GreaterThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint8PGreaterOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint8(2)

	v = Is(Uint8P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = uint8(3)

	v = Is(Uint8P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint8P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint8PGreaterOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint8(2)
	number1 := &_number1

	v = Is(Uint8P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint8P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Uint8P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint8PLessThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint8(2)

	v = Is(Uint8P(&number1).LessThan(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Uint8P(&myNumber1).LessThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint8PLessThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint8(2)
	number1 := &_number1

	v = Is(Uint8P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = uint8(3)

	v = Is(Uint8P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint8P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint8P(&myNumber1).LessThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint8PLessOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint8(2)

	v = Is(Uint8P(&number1).LessOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	v = Is(Uint8P(&number1).LessOrEqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint8P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint8PLessOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint8(3)
	number1 := &_number1

	v = Is(Uint8P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil
	v = Is(Uint8P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Uint8P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint8PBetweenValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint8(2)

	v = Is(Uint8P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = uint8(4)

	v = Is(Uint8P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = uint8(6)

	v = Is(Uint8P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2
	var myNumber3 MyNumber = 6

	v = Is(Uint8P(&myNumber1).Between(myNumber2, myNumber3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint8PBetweenInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint8(2)
	number1 := &_number1

	v = Is(Uint8P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = uint8(7)

	v = Is(Uint8P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint8P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3
	var myNumber3 MyNumber = 6

	v = Is(Uint8P(&myNumber1).Between(myNumber2, myNumber3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint8PZeroValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint8(0)
	number1 := &_number1

	v = Is(Uint8P(number1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 0

	v = Is(Uint8P(&myNumber1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint8PZeroInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint8(1)
	number1 := &_number1

	v = Is(Uint8P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint8P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 1

	v = Is(Uint8P(&myNumber1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint8PZeroOrNilValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint8(0)
	number1 := &_number1

	v = Is(Uint8P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = nil

	v = Is(Uint8P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 0

	v = Is(Uint8P(&myNumber1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint8PZeroOrNilInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint8(1)

	v = Is(Uint8P(&number1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 1

	v = Is(Uint8P(&myNumber1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint8PPassingValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := uint8(2)

	v = Is(Uint8P(&number1).Passing(func(val *uint8) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 2

	v = Is(Uint8P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorUint8PPassingInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := uint8(1)

	v = Is(Uint8P(&number1).Passing(func(val *uint8) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 1

	v = Is(Uint8P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint8PInSliceValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := uint8(2)

	v = Is(Uint8P(&number1).InSlice([]uint8{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 2

	v = Is(Uint8P(&myNumber1).InSlice([]MyNumber{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint8PInSliceInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	_number1 := uint8(1)
	number1 := &_number1

	v = Is(Uint8P(number1).InSlice([]uint8{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint8P(number1).InSlice([]uint8{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 1

	v = Is(Uint8P(&myNumber1).InSlice([]MyNumber{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint8PNilIsValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	var valNumber *uint8

	v = Is(Uint8P(valNumber).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint8
	var myNumber1 *MyNumber

	v = Is(Uint8P(myNumber1).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorUint8PNilIsInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	valNumber := uint8(1)

	v = Is(Uint8P(&valNumber).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint8
	var myNumber1 MyNumber = 1

	v = Is(Uint8P(&myNumber1).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])
}



func TestValidatorUint16PNot(t *testing.T) {
	ResetMessages()

	number1 := uint16(2)

	v := Is(Uint16P(&number1).Not().EqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorUint16PEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint16(2)

	v = Is(Uint16P(&number1).EqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint16P(&myNumber1).EqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint16PEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint16(2)
	number1 := &_number1

	v = Is(Uint16P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint16P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Uint16P(&myNumber1).EqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint16PGreaterThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint16(3)

	v = Is(Uint16P(&number1).GreaterThan(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Uint16P(&myNumber1).GreaterThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorUint16PGreaterThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint16(2)
	number1 := &_number1

	v = Is(Uint16P(number1).GreaterThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = 2

	v = Is(Uint16P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint16P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint16P(&myNumber1).GreaterThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint16PGreaterOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint16(2)

	v = Is(Uint16P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = uint16(3)

	v = Is(Uint16P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint16P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint16PGreaterOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint16(2)
	number1 := &_number1

	v = Is(Uint16P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint16P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Uint16P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint16PLessThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint16(2)

	v = Is(Uint16P(&number1).LessThan(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Uint16P(&myNumber1).LessThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint16PLessThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint16(2)
	number1 := &_number1

	v = Is(Uint16P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = uint16(3)

	v = Is(Uint16P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint16P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint16P(&myNumber1).LessThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint16PLessOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint16(2)

	v = Is(Uint16P(&number1).LessOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	v = Is(Uint16P(&number1).LessOrEqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint16P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint16PLessOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint16(3)
	number1 := &_number1

	v = Is(Uint16P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil
	v = Is(Uint16P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Uint16P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint16PBetweenValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint16(2)

	v = Is(Uint16P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = uint16(4)

	v = Is(Uint16P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = uint16(6)

	v = Is(Uint16P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2
	var myNumber3 MyNumber = 6

	v = Is(Uint16P(&myNumber1).Between(myNumber2, myNumber3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint16PBetweenInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint16(2)
	number1 := &_number1

	v = Is(Uint16P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = uint16(7)

	v = Is(Uint16P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint16P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3
	var myNumber3 MyNumber = 6

	v = Is(Uint16P(&myNumber1).Between(myNumber2, myNumber3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint16PZeroValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint16(0)
	number1 := &_number1

	v = Is(Uint16P(number1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 0

	v = Is(Uint16P(&myNumber1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint16PZeroInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint16(1)
	number1 := &_number1

	v = Is(Uint16P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint16P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 1

	v = Is(Uint16P(&myNumber1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint16PZeroOrNilValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint16(0)
	number1 := &_number1

	v = Is(Uint16P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = nil

	v = Is(Uint16P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 0

	v = Is(Uint16P(&myNumber1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint16PZeroOrNilInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint16(1)

	v = Is(Uint16P(&number1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 1

	v = Is(Uint16P(&myNumber1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint16PPassingValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := uint16(2)

	v = Is(Uint16P(&number1).Passing(func(val *uint16) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 2

	v = Is(Uint16P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorUint16PPassingInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := uint16(1)

	v = Is(Uint16P(&number1).Passing(func(val *uint16) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 1

	v = Is(Uint16P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint16PInSliceValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := uint16(2)

	v = Is(Uint16P(&number1).InSlice([]uint16{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 2

	v = Is(Uint16P(&myNumber1).InSlice([]MyNumber{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint16PInSliceInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	_number1 := uint16(1)
	number1 := &_number1

	v = Is(Uint16P(number1).InSlice([]uint16{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint16P(number1).InSlice([]uint16{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 1

	v = Is(Uint16P(&myNumber1).InSlice([]MyNumber{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint16PNilIsValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	var valNumber *uint16

	v = Is(Uint16P(valNumber).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint16
	var myNumber1 *MyNumber

	v = Is(Uint16P(myNumber1).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorUint16PNilIsInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	valNumber := uint16(1)

	v = Is(Uint16P(&valNumber).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint16
	var myNumber1 MyNumber = 1

	v = Is(Uint16P(&myNumber1).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])
}



func TestValidatorUint32PNot(t *testing.T) {
	ResetMessages()

	number1 := uint32(2)

	v := Is(Uint32P(&number1).Not().EqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorUint32PEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint32(2)

	v = Is(Uint32P(&number1).EqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint32P(&myNumber1).EqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint32PEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint32(2)
	number1 := &_number1

	v = Is(Uint32P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint32P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Uint32P(&myNumber1).EqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint32PGreaterThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint32(3)

	v = Is(Uint32P(&number1).GreaterThan(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Uint32P(&myNumber1).GreaterThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorUint32PGreaterThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint32(2)
	number1 := &_number1

	v = Is(Uint32P(number1).GreaterThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = 2

	v = Is(Uint32P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint32P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint32P(&myNumber1).GreaterThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint32PGreaterOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint32(2)

	v = Is(Uint32P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = uint32(3)

	v = Is(Uint32P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint32P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint32PGreaterOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint32(2)
	number1 := &_number1

	v = Is(Uint32P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint32P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Uint32P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint32PLessThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint32(2)

	v = Is(Uint32P(&number1).LessThan(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Uint32P(&myNumber1).LessThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint32PLessThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint32(2)
	number1 := &_number1

	v = Is(Uint32P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = uint32(3)

	v = Is(Uint32P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint32P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint32P(&myNumber1).LessThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint32PLessOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint32(2)

	v = Is(Uint32P(&number1).LessOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	v = Is(Uint32P(&number1).LessOrEqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint32P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint32PLessOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint32(3)
	number1 := &_number1

	v = Is(Uint32P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil
	v = Is(Uint32P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Uint32P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint32PBetweenValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint32(2)

	v = Is(Uint32P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = uint32(4)

	v = Is(Uint32P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = uint32(6)

	v = Is(Uint32P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2
	var myNumber3 MyNumber = 6

	v = Is(Uint32P(&myNumber1).Between(myNumber2, myNumber3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint32PBetweenInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint32(2)
	number1 := &_number1

	v = Is(Uint32P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = uint32(7)

	v = Is(Uint32P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint32P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3
	var myNumber3 MyNumber = 6

	v = Is(Uint32P(&myNumber1).Between(myNumber2, myNumber3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint32PZeroValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint32(0)
	number1 := &_number1

	v = Is(Uint32P(number1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 0

	v = Is(Uint32P(&myNumber1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint32PZeroInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint32(1)
	number1 := &_number1

	v = Is(Uint32P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint32P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 1

	v = Is(Uint32P(&myNumber1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint32PZeroOrNilValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint32(0)
	number1 := &_number1

	v = Is(Uint32P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = nil

	v = Is(Uint32P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 0

	v = Is(Uint32P(&myNumber1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint32PZeroOrNilInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint32(1)

	v = Is(Uint32P(&number1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 1

	v = Is(Uint32P(&myNumber1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint32PPassingValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := uint32(2)

	v = Is(Uint32P(&number1).Passing(func(val *uint32) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 2

	v = Is(Uint32P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorUint32PPassingInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := uint32(1)

	v = Is(Uint32P(&number1).Passing(func(val *uint32) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 1

	v = Is(Uint32P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint32PInSliceValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := uint32(2)

	v = Is(Uint32P(&number1).InSlice([]uint32{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 2

	v = Is(Uint32P(&myNumber1).InSlice([]MyNumber{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint32PInSliceInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	_number1 := uint32(1)
	number1 := &_number1

	v = Is(Uint32P(number1).InSlice([]uint32{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint32P(number1).InSlice([]uint32{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 1

	v = Is(Uint32P(&myNumber1).InSlice([]MyNumber{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint32PNilIsValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	var valNumber *uint32

	v = Is(Uint32P(valNumber).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint32
	var myNumber1 *MyNumber

	v = Is(Uint32P(myNumber1).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorUint32PNilIsInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	valNumber := uint32(1)

	v = Is(Uint32P(&valNumber).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint32
	var myNumber1 MyNumber = 1

	v = Is(Uint32P(&myNumber1).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])
}



func TestValidatorUint64PNot(t *testing.T) {
	ResetMessages()

	number1 := uint64(2)

	v := Is(Uint64P(&number1).Not().EqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorUint64PEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint64(2)

	v = Is(Uint64P(&number1).EqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint64P(&myNumber1).EqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint64PEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint64(2)
	number1 := &_number1

	v = Is(Uint64P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint64P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Uint64P(&myNumber1).EqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint64PGreaterThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint64(3)

	v = Is(Uint64P(&number1).GreaterThan(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Uint64P(&myNumber1).GreaterThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorUint64PGreaterThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint64(2)
	number1 := &_number1

	v = Is(Uint64P(number1).GreaterThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = 2

	v = Is(Uint64P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint64P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint64P(&myNumber1).GreaterThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint64PGreaterOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint64(2)

	v = Is(Uint64P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = uint64(3)

	v = Is(Uint64P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint64P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint64PGreaterOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint64(2)
	number1 := &_number1

	v = Is(Uint64P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint64P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Uint64P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint64PLessThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint64(2)

	v = Is(Uint64P(&number1).LessThan(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Uint64P(&myNumber1).LessThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint64PLessThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint64(2)
	number1 := &_number1

	v = Is(Uint64P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = uint64(3)

	v = Is(Uint64P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint64P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint64P(&myNumber1).LessThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint64PLessOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint64(2)

	v = Is(Uint64P(&number1).LessOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	v = Is(Uint64P(&number1).LessOrEqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Uint64P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint64PLessOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint64(3)
	number1 := &_number1

	v = Is(Uint64P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil
	v = Is(Uint64P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Uint64P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint64PBetweenValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint64(2)

	v = Is(Uint64P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = uint64(4)

	v = Is(Uint64P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = uint64(6)

	v = Is(Uint64P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2
	var myNumber3 MyNumber = 6

	v = Is(Uint64P(&myNumber1).Between(myNumber2, myNumber3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint64PBetweenInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint64(2)
	number1 := &_number1

	v = Is(Uint64P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = uint64(7)

	v = Is(Uint64P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint64P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3
	var myNumber3 MyNumber = 6

	v = Is(Uint64P(&myNumber1).Between(myNumber2, myNumber3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint64PZeroValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint64(0)
	number1 := &_number1

	v = Is(Uint64P(number1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 0

	v = Is(Uint64P(&myNumber1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint64PZeroInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint64(1)
	number1 := &_number1

	v = Is(Uint64P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint64P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 1

	v = Is(Uint64P(&myNumber1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint64PZeroOrNilValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := uint64(0)
	number1 := &_number1

	v = Is(Uint64P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = nil

	v = Is(Uint64P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 0

	v = Is(Uint64P(&myNumber1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint64PZeroOrNilInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := uint64(1)

	v = Is(Uint64P(&number1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 1

	v = Is(Uint64P(&myNumber1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint64PPassingValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := uint64(2)

	v = Is(Uint64P(&number1).Passing(func(val *uint64) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 2

	v = Is(Uint64P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorUint64PPassingInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := uint64(1)

	v = Is(Uint64P(&number1).Passing(func(val *uint64) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 1

	v = Is(Uint64P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint64PInSliceValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := uint64(2)

	v = Is(Uint64P(&number1).InSlice([]uint64{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 2

	v = Is(Uint64P(&myNumber1).InSlice([]MyNumber{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorUint64PInSliceInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	_number1 := uint64(1)
	number1 := &_number1

	v = Is(Uint64P(number1).InSlice([]uint64{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Uint64P(number1).InSlice([]uint64{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 1

	v = Is(Uint64P(&myNumber1).InSlice([]MyNumber{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorUint64PNilIsValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	var valNumber *uint64

	v = Is(Uint64P(valNumber).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber uint64
	var myNumber1 *MyNumber

	v = Is(Uint64P(myNumber1).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorUint64PNilIsInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	valNumber := uint64(1)

	v = Is(Uint64P(&valNumber).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber uint64
	var myNumber1 MyNumber = 1

	v = Is(Uint64P(&myNumber1).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])
}



func TestValidatorIntPNot(t *testing.T) {
	ResetMessages()

	number1 := int(2)

	v := Is(IntP(&number1).Not().EqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorIntPEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int(2)

	v = Is(IntP(&number1).EqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(IntP(&myNumber1).EqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorIntPEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int(2)
	number1 := &_number1

	v = Is(IntP(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(IntP(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(IntP(&myNumber1).EqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorIntPGreaterThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int(3)

	v = Is(IntP(&number1).GreaterThan(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(IntP(&myNumber1).GreaterThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorIntPGreaterThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int(2)
	number1 := &_number1

	v = Is(IntP(number1).GreaterThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = 2

	v = Is(IntP(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(IntP(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(IntP(&myNumber1).GreaterThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorIntPGreaterOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int(2)

	v = Is(IntP(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = int(3)

	v = Is(IntP(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(IntP(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorIntPGreaterOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int(2)
	number1 := &_number1

	v = Is(IntP(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(IntP(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(IntP(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorIntPLessThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int(2)

	v = Is(IntP(&number1).LessThan(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(IntP(&myNumber1).LessThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorIntPLessThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int(2)
	number1 := &_number1

	v = Is(IntP(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = int(3)

	v = Is(IntP(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(IntP(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(IntP(&myNumber1).LessThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorIntPLessOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int(2)

	v = Is(IntP(&number1).LessOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	v = Is(IntP(&number1).LessOrEqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(IntP(&myNumber1).LessOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorIntPLessOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int(3)
	number1 := &_number1

	v = Is(IntP(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil
	v = Is(IntP(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(IntP(&myNumber1).LessOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorIntPBetweenValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int(2)

	v = Is(IntP(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = int(4)

	v = Is(IntP(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = int(6)

	v = Is(IntP(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2
	var myNumber3 MyNumber = 6

	v = Is(IntP(&myNumber1).Between(myNumber2, myNumber3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorIntPBetweenInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int(2)
	number1 := &_number1

	v = Is(IntP(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = int(7)

	v = Is(IntP(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(IntP(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3
	var myNumber3 MyNumber = 6

	v = Is(IntP(&myNumber1).Between(myNumber2, myNumber3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorIntPZeroValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int(0)
	number1 := &_number1

	v = Is(IntP(number1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 0

	v = Is(IntP(&myNumber1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorIntPZeroInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int(1)
	number1 := &_number1

	v = Is(IntP(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(IntP(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 1

	v = Is(IntP(&myNumber1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorIntPZeroOrNilValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int(0)
	number1 := &_number1

	v = Is(IntP(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = nil

	v = Is(IntP(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 0

	v = Is(IntP(&myNumber1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorIntPZeroOrNilInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int(1)

	v = Is(IntP(&number1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 1

	v = Is(IntP(&myNumber1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorIntPPassingValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := int(2)

	v = Is(IntP(&number1).Passing(func(val *int) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 2

	v = Is(IntP(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorIntPPassingInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := int(1)

	v = Is(IntP(&number1).Passing(func(val *int) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 1

	v = Is(IntP(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorIntPInSliceValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := int(2)

	v = Is(IntP(&number1).InSlice([]int{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 2

	v = Is(IntP(&myNumber1).InSlice([]MyNumber{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorIntPInSliceInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	_number1 := int(1)
	number1 := &_number1

	v = Is(IntP(number1).InSlice([]int{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(IntP(number1).InSlice([]int{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 1

	v = Is(IntP(&myNumber1).InSlice([]MyNumber{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorIntPNilIsValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	var valNumber *int

	v = Is(IntP(valNumber).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int
	var myNumber1 *MyNumber

	v = Is(IntP(myNumber1).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorIntPNilIsInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	valNumber := int(1)

	v = Is(IntP(&valNumber).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int
	var myNumber1 MyNumber = 1

	v = Is(IntP(&myNumber1).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])
}



func TestValidatorInt8PNot(t *testing.T) {
	ResetMessages()

	number1 := int8(2)

	v := Is(Int8P(&number1).Not().EqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorInt8PEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int8(2)

	v = Is(Int8P(&number1).EqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int8P(&myNumber1).EqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt8PEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int8(2)
	number1 := &_number1

	v = Is(Int8P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int8P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Int8P(&myNumber1).EqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt8PGreaterThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int8(3)

	v = Is(Int8P(&number1).GreaterThan(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Int8P(&myNumber1).GreaterThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorInt8PGreaterThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int8(2)
	number1 := &_number1

	v = Is(Int8P(number1).GreaterThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = 2

	v = Is(Int8P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int8P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int8P(&myNumber1).GreaterThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt8PGreaterOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int8(2)

	v = Is(Int8P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = int8(3)

	v = Is(Int8P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int8P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt8PGreaterOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int8(2)
	number1 := &_number1

	v = Is(Int8P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int8P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Int8P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt8PLessThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int8(2)

	v = Is(Int8P(&number1).LessThan(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Int8P(&myNumber1).LessThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt8PLessThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int8(2)
	number1 := &_number1

	v = Is(Int8P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = int8(3)

	v = Is(Int8P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int8P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int8P(&myNumber1).LessThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt8PLessOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int8(2)

	v = Is(Int8P(&number1).LessOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	v = Is(Int8P(&number1).LessOrEqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int8P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt8PLessOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int8(3)
	number1 := &_number1

	v = Is(Int8P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil
	v = Is(Int8P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Int8P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt8PBetweenValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int8(2)

	v = Is(Int8P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = int8(4)

	v = Is(Int8P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = int8(6)

	v = Is(Int8P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2
	var myNumber3 MyNumber = 6

	v = Is(Int8P(&myNumber1).Between(myNumber2, myNumber3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt8PBetweenInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int8(2)
	number1 := &_number1

	v = Is(Int8P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = int8(7)

	v = Is(Int8P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int8P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3
	var myNumber3 MyNumber = 6

	v = Is(Int8P(&myNumber1).Between(myNumber2, myNumber3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt8PZeroValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int8(0)
	number1 := &_number1

	v = Is(Int8P(number1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 0

	v = Is(Int8P(&myNumber1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt8PZeroInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int8(1)
	number1 := &_number1

	v = Is(Int8P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int8P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 1

	v = Is(Int8P(&myNumber1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt8PZeroOrNilValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int8(0)
	number1 := &_number1

	v = Is(Int8P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = nil

	v = Is(Int8P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 0

	v = Is(Int8P(&myNumber1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt8PZeroOrNilInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int8(1)

	v = Is(Int8P(&number1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 1

	v = Is(Int8P(&myNumber1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt8PPassingValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := int8(2)

	v = Is(Int8P(&number1).Passing(func(val *int8) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 2

	v = Is(Int8P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorInt8PPassingInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := int8(1)

	v = Is(Int8P(&number1).Passing(func(val *int8) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 1

	v = Is(Int8P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt8PInSliceValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := int8(2)

	v = Is(Int8P(&number1).InSlice([]int8{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 2

	v = Is(Int8P(&myNumber1).InSlice([]MyNumber{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt8PInSliceInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	_number1 := int8(1)
	number1 := &_number1

	v = Is(Int8P(number1).InSlice([]int8{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int8P(number1).InSlice([]int8{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 1

	v = Is(Int8P(&myNumber1).InSlice([]MyNumber{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt8PNilIsValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	var valNumber *int8

	v = Is(Int8P(valNumber).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int8
	var myNumber1 *MyNumber

	v = Is(Int8P(myNumber1).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorInt8PNilIsInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	valNumber := int8(1)

	v = Is(Int8P(&valNumber).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int8
	var myNumber1 MyNumber = 1

	v = Is(Int8P(&myNumber1).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])
}



func TestValidatorInt16PNot(t *testing.T) {
	ResetMessages()

	number1 := int16(2)

	v := Is(Int16P(&number1).Not().EqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorInt16PEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int16(2)

	v = Is(Int16P(&number1).EqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int16P(&myNumber1).EqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt16PEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int16(2)
	number1 := &_number1

	v = Is(Int16P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int16P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Int16P(&myNumber1).EqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt16PGreaterThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int16(3)

	v = Is(Int16P(&number1).GreaterThan(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Int16P(&myNumber1).GreaterThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorInt16PGreaterThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int16(2)
	number1 := &_number1

	v = Is(Int16P(number1).GreaterThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = 2

	v = Is(Int16P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int16P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int16P(&myNumber1).GreaterThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt16PGreaterOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int16(2)

	v = Is(Int16P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = int16(3)

	v = Is(Int16P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int16P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt16PGreaterOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int16(2)
	number1 := &_number1

	v = Is(Int16P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int16P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Int16P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt16PLessThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int16(2)

	v = Is(Int16P(&number1).LessThan(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Int16P(&myNumber1).LessThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt16PLessThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int16(2)
	number1 := &_number1

	v = Is(Int16P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = int16(3)

	v = Is(Int16P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int16P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int16P(&myNumber1).LessThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt16PLessOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int16(2)

	v = Is(Int16P(&number1).LessOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	v = Is(Int16P(&number1).LessOrEqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int16P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt16PLessOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int16(3)
	number1 := &_number1

	v = Is(Int16P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil
	v = Is(Int16P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Int16P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt16PBetweenValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int16(2)

	v = Is(Int16P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = int16(4)

	v = Is(Int16P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = int16(6)

	v = Is(Int16P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2
	var myNumber3 MyNumber = 6

	v = Is(Int16P(&myNumber1).Between(myNumber2, myNumber3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt16PBetweenInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int16(2)
	number1 := &_number1

	v = Is(Int16P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = int16(7)

	v = Is(Int16P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int16P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3
	var myNumber3 MyNumber = 6

	v = Is(Int16P(&myNumber1).Between(myNumber2, myNumber3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt16PZeroValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int16(0)
	number1 := &_number1

	v = Is(Int16P(number1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 0

	v = Is(Int16P(&myNumber1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt16PZeroInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int16(1)
	number1 := &_number1

	v = Is(Int16P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int16P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 1

	v = Is(Int16P(&myNumber1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt16PZeroOrNilValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int16(0)
	number1 := &_number1

	v = Is(Int16P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = nil

	v = Is(Int16P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 0

	v = Is(Int16P(&myNumber1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt16PZeroOrNilInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int16(1)

	v = Is(Int16P(&number1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 1

	v = Is(Int16P(&myNumber1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt16PPassingValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := int16(2)

	v = Is(Int16P(&number1).Passing(func(val *int16) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 2

	v = Is(Int16P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorInt16PPassingInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := int16(1)

	v = Is(Int16P(&number1).Passing(func(val *int16) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 1

	v = Is(Int16P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt16PInSliceValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := int16(2)

	v = Is(Int16P(&number1).InSlice([]int16{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 2

	v = Is(Int16P(&myNumber1).InSlice([]MyNumber{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt16PInSliceInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	_number1 := int16(1)
	number1 := &_number1

	v = Is(Int16P(number1).InSlice([]int16{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int16P(number1).InSlice([]int16{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 1

	v = Is(Int16P(&myNumber1).InSlice([]MyNumber{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt16PNilIsValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	var valNumber *int16

	v = Is(Int16P(valNumber).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int16
	var myNumber1 *MyNumber

	v = Is(Int16P(myNumber1).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorInt16PNilIsInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	valNumber := int16(1)

	v = Is(Int16P(&valNumber).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int16
	var myNumber1 MyNumber = 1

	v = Is(Int16P(&myNumber1).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])
}



func TestValidatorInt32PNot(t *testing.T) {
	ResetMessages()

	number1 := int32(2)

	v := Is(Int32P(&number1).Not().EqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorInt32PEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int32(2)

	v = Is(Int32P(&number1).EqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int32P(&myNumber1).EqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt32PEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int32(2)
	number1 := &_number1

	v = Is(Int32P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int32P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Int32P(&myNumber1).EqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt32PGreaterThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int32(3)

	v = Is(Int32P(&number1).GreaterThan(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Int32P(&myNumber1).GreaterThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorInt32PGreaterThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int32(2)
	number1 := &_number1

	v = Is(Int32P(number1).GreaterThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = 2

	v = Is(Int32P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int32P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int32P(&myNumber1).GreaterThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt32PGreaterOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int32(2)

	v = Is(Int32P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = int32(3)

	v = Is(Int32P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int32P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt32PGreaterOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int32(2)
	number1 := &_number1

	v = Is(Int32P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int32P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Int32P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt32PLessThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int32(2)

	v = Is(Int32P(&number1).LessThan(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Int32P(&myNumber1).LessThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt32PLessThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int32(2)
	number1 := &_number1

	v = Is(Int32P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = int32(3)

	v = Is(Int32P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int32P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int32P(&myNumber1).LessThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt32PLessOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int32(2)

	v = Is(Int32P(&number1).LessOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	v = Is(Int32P(&number1).LessOrEqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int32P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt32PLessOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int32(3)
	number1 := &_number1

	v = Is(Int32P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil
	v = Is(Int32P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Int32P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt32PBetweenValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int32(2)

	v = Is(Int32P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = int32(4)

	v = Is(Int32P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = int32(6)

	v = Is(Int32P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2
	var myNumber3 MyNumber = 6

	v = Is(Int32P(&myNumber1).Between(myNumber2, myNumber3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt32PBetweenInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int32(2)
	number1 := &_number1

	v = Is(Int32P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = int32(7)

	v = Is(Int32P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int32P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3
	var myNumber3 MyNumber = 6

	v = Is(Int32P(&myNumber1).Between(myNumber2, myNumber3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt32PZeroValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int32(0)
	number1 := &_number1

	v = Is(Int32P(number1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 0

	v = Is(Int32P(&myNumber1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt32PZeroInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int32(1)
	number1 := &_number1

	v = Is(Int32P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int32P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 1

	v = Is(Int32P(&myNumber1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt32PZeroOrNilValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int32(0)
	number1 := &_number1

	v = Is(Int32P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = nil

	v = Is(Int32P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 0

	v = Is(Int32P(&myNumber1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt32PZeroOrNilInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int32(1)

	v = Is(Int32P(&number1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 1

	v = Is(Int32P(&myNumber1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt32PPassingValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := int32(2)

	v = Is(Int32P(&number1).Passing(func(val *int32) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 2

	v = Is(Int32P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorInt32PPassingInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := int32(1)

	v = Is(Int32P(&number1).Passing(func(val *int32) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 1

	v = Is(Int32P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt32PInSliceValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := int32(2)

	v = Is(Int32P(&number1).InSlice([]int32{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 2

	v = Is(Int32P(&myNumber1).InSlice([]MyNumber{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt32PInSliceInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	_number1 := int32(1)
	number1 := &_number1

	v = Is(Int32P(number1).InSlice([]int32{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int32P(number1).InSlice([]int32{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 1

	v = Is(Int32P(&myNumber1).InSlice([]MyNumber{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt32PNilIsValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	var valNumber *int32

	v = Is(Int32P(valNumber).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int32
	var myNumber1 *MyNumber

	v = Is(Int32P(myNumber1).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorInt32PNilIsInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	valNumber := int32(1)

	v = Is(Int32P(&valNumber).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int32
	var myNumber1 MyNumber = 1

	v = Is(Int32P(&myNumber1).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])
}



func TestValidatorInt64PNot(t *testing.T) {
	ResetMessages()

	number1 := int64(2)

	v := Is(Int64P(&number1).Not().EqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorInt64PEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int64(2)

	v = Is(Int64P(&number1).EqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int64P(&myNumber1).EqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt64PEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int64(2)
	number1 := &_number1

	v = Is(Int64P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int64P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Int64P(&myNumber1).EqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt64PGreaterThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int64(3)

	v = Is(Int64P(&number1).GreaterThan(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Int64P(&myNumber1).GreaterThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorInt64PGreaterThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int64(2)
	number1 := &_number1

	v = Is(Int64P(number1).GreaterThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = 2

	v = Is(Int64P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int64P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int64P(&myNumber1).GreaterThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt64PGreaterOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int64(2)

	v = Is(Int64P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = int64(3)

	v = Is(Int64P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int64P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt64PGreaterOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int64(2)
	number1 := &_number1

	v = Is(Int64P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int64P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Int64P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt64PLessThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int64(2)

	v = Is(Int64P(&number1).LessThan(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Int64P(&myNumber1).LessThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt64PLessThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int64(2)
	number1 := &_number1

	v = Is(Int64P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = int64(3)

	v = Is(Int64P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int64P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int64P(&myNumber1).LessThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt64PLessOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int64(2)

	v = Is(Int64P(&number1).LessOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	v = Is(Int64P(&number1).LessOrEqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Int64P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt64PLessOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int64(3)
	number1 := &_number1

	v = Is(Int64P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil
	v = Is(Int64P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Int64P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt64PBetweenValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int64(2)

	v = Is(Int64P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = int64(4)

	v = Is(Int64P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = int64(6)

	v = Is(Int64P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2
	var myNumber3 MyNumber = 6

	v = Is(Int64P(&myNumber1).Between(myNumber2, myNumber3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt64PBetweenInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int64(2)
	number1 := &_number1

	v = Is(Int64P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = int64(7)

	v = Is(Int64P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int64P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3
	var myNumber3 MyNumber = 6

	v = Is(Int64P(&myNumber1).Between(myNumber2, myNumber3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt64PZeroValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int64(0)
	number1 := &_number1

	v = Is(Int64P(number1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 0

	v = Is(Int64P(&myNumber1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt64PZeroInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int64(1)
	number1 := &_number1

	v = Is(Int64P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int64P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 1

	v = Is(Int64P(&myNumber1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt64PZeroOrNilValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := int64(0)
	number1 := &_number1

	v = Is(Int64P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = nil

	v = Is(Int64P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 0

	v = Is(Int64P(&myNumber1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt64PZeroOrNilInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := int64(1)

	v = Is(Int64P(&number1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 1

	v = Is(Int64P(&myNumber1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt64PPassingValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := int64(2)

	v = Is(Int64P(&number1).Passing(func(val *int64) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 2

	v = Is(Int64P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorInt64PPassingInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := int64(1)

	v = Is(Int64P(&number1).Passing(func(val *int64) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 1

	v = Is(Int64P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt64PInSliceValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := int64(2)

	v = Is(Int64P(&number1).InSlice([]int64{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 2

	v = Is(Int64P(&myNumber1).InSlice([]MyNumber{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorInt64PInSliceInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	_number1 := int64(1)
	number1 := &_number1

	v = Is(Int64P(number1).InSlice([]int64{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Int64P(number1).InSlice([]int64{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 1

	v = Is(Int64P(&myNumber1).InSlice([]MyNumber{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorInt64PNilIsValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	var valNumber *int64

	v = Is(Int64P(valNumber).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber int64
	var myNumber1 *MyNumber

	v = Is(Int64P(myNumber1).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorInt64PNilIsInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	valNumber := int64(1)

	v = Is(Int64P(&valNumber).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber int64
	var myNumber1 MyNumber = 1

	v = Is(Int64P(&myNumber1).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])
}



func TestValidatorFloat32PNot(t *testing.T) {
	ResetMessages()

	number1 := float32(2)

	v := Is(Float32P(&number1).Not().EqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorFloat32PEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := float32(2)

	v = Is(Float32P(&number1).EqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Float32P(&myNumber1).EqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorFloat32PEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := float32(2)
	number1 := &_number1

	v = Is(Float32P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Float32P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Float32P(&myNumber1).EqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat32PGreaterThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := float32(3)

	v = Is(Float32P(&number1).GreaterThan(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Float32P(&myNumber1).GreaterThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorFloat32PGreaterThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := float32(2)
	number1 := &_number1

	v = Is(Float32P(number1).GreaterThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = 2

	v = Is(Float32P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Float32P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Float32P(&myNumber1).GreaterThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat32PGreaterOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := float32(2)

	v = Is(Float32P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = float32(3)

	v = Is(Float32P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Float32P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorFloat32PGreaterOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := float32(2)
	number1 := &_number1

	v = Is(Float32P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Float32P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Float32P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat32PLessThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := float32(2)

	v = Is(Float32P(&number1).LessThan(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Float32P(&myNumber1).LessThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorFloat32PLessThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := float32(2)
	number1 := &_number1

	v = Is(Float32P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = float32(3)

	v = Is(Float32P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Float32P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Float32P(&myNumber1).LessThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat32PLessOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := float32(2)

	v = Is(Float32P(&number1).LessOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	v = Is(Float32P(&number1).LessOrEqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Float32P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorFloat32PLessOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := float32(3)
	number1 := &_number1

	v = Is(Float32P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil
	v = Is(Float32P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Float32P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat32PBetweenValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := float32(2)

	v = Is(Float32P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = float32(4)

	v = Is(Float32P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = float32(6)

	v = Is(Float32P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2
	var myNumber3 MyNumber = 6

	v = Is(Float32P(&myNumber1).Between(myNumber2, myNumber3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorFloat32PBetweenInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := float32(2)
	number1 := &_number1

	v = Is(Float32P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = float32(7)

	v = Is(Float32P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Float32P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3
	var myNumber3 MyNumber = 6

	v = Is(Float32P(&myNumber1).Between(myNumber2, myNumber3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat32PZeroValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := float32(0)
	number1 := &_number1

	v = Is(Float32P(number1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 0

	v = Is(Float32P(&myNumber1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorFloat32PZeroInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := float32(1)
	number1 := &_number1

	v = Is(Float32P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Float32P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 1

	v = Is(Float32P(&myNumber1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat32PZeroOrNilValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := float32(0)
	number1 := &_number1

	v = Is(Float32P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = nil

	v = Is(Float32P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 0

	v = Is(Float32P(&myNumber1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorFloat32PZeroOrNilInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := float32(1)

	v = Is(Float32P(&number1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 1

	v = Is(Float32P(&myNumber1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat32PPassingValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := float32(2)

	v = Is(Float32P(&number1).Passing(func(val *float32) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 2

	v = Is(Float32P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorFloat32PPassingInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := float32(1)

	v = Is(Float32P(&number1).Passing(func(val *float32) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 1

	v = Is(Float32P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat32PInSliceValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := float32(2)

	v = Is(Float32P(&number1).InSlice([]float32{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 2

	v = Is(Float32P(&myNumber1).InSlice([]MyNumber{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorFloat32PInSliceInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	_number1 := float32(1)
	number1 := &_number1

	v = Is(Float32P(number1).InSlice([]float32{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Float32P(number1).InSlice([]float32{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 1

	v = Is(Float32P(&myNumber1).InSlice([]MyNumber{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat32PNilIsValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	var valNumber *float32

	v = Is(Float32P(valNumber).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float32
	var myNumber1 *MyNumber

	v = Is(Float32P(myNumber1).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorFloat32PNilIsInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	valNumber := float32(1)

	v = Is(Float32P(&valNumber).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float32
	var myNumber1 MyNumber = 1

	v = Is(Float32P(&myNumber1).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])
}



func TestValidatorFloat64PNot(t *testing.T) {
	ResetMessages()

	number1 := float64(2)

	v := Is(Float64P(&number1).Not().EqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorFloat64PEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := float64(2)

	v = Is(Float64P(&number1).EqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Float64P(&myNumber1).EqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorFloat64PEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := float64(2)
	number1 := &_number1

	v = Is(Float64P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Float64P(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Float64P(&myNumber1).EqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat64PGreaterThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := float64(3)

	v = Is(Float64P(&number1).GreaterThan(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Float64P(&myNumber1).GreaterThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorFloat64PGreaterThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := float64(2)
	number1 := &_number1

	v = Is(Float64P(number1).GreaterThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = 2

	v = Is(Float64P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Float64P(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Float64P(&myNumber1).GreaterThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat64PGreaterOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := float64(2)

	v = Is(Float64P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = float64(3)

	v = Is(Float64P(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Float64P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorFloat64PGreaterOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := float64(2)
	number1 := &_number1

	v = Is(Float64P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Float64P(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Float64P(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat64PLessThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := float64(2)

	v = Is(Float64P(&number1).LessThan(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(Float64P(&myNumber1).LessThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorFloat64PLessThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := float64(2)
	number1 := &_number1

	v = Is(Float64P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = float64(3)

	v = Is(Float64P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Float64P(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Float64P(&myNumber1).LessThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat64PLessOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := float64(2)

	v = Is(Float64P(&number1).LessOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	v = Is(Float64P(&number1).LessOrEqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(Float64P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorFloat64PLessOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := float64(3)
	number1 := &_number1

	v = Is(Float64P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil
	v = Is(Float64P(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(Float64P(&myNumber1).LessOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat64PBetweenValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := float64(2)

	v = Is(Float64P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = float64(4)

	v = Is(Float64P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = float64(6)

	v = Is(Float64P(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2
	var myNumber3 MyNumber = 6

	v = Is(Float64P(&myNumber1).Between(myNumber2, myNumber3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorFloat64PBetweenInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := float64(2)
	number1 := &_number1

	v = Is(Float64P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = float64(7)

	v = Is(Float64P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Float64P(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3
	var myNumber3 MyNumber = 6

	v = Is(Float64P(&myNumber1).Between(myNumber2, myNumber3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat64PZeroValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := float64(0)
	number1 := &_number1

	v = Is(Float64P(number1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 0

	v = Is(Float64P(&myNumber1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorFloat64PZeroInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := float64(1)
	number1 := &_number1

	v = Is(Float64P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Float64P(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 1

	v = Is(Float64P(&myNumber1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat64PZeroOrNilValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := float64(0)
	number1 := &_number1

	v = Is(Float64P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = nil

	v = Is(Float64P(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 0

	v = Is(Float64P(&myNumber1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorFloat64PZeroOrNilInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := float64(1)

	v = Is(Float64P(&number1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 1

	v = Is(Float64P(&myNumber1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat64PPassingValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := float64(2)

	v = Is(Float64P(&number1).Passing(func(val *float64) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 2

	v = Is(Float64P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorFloat64PPassingInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := float64(1)

	v = Is(Float64P(&number1).Passing(func(val *float64) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 1

	v = Is(Float64P(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat64PInSliceValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := float64(2)

	v = Is(Float64P(&number1).InSlice([]float64{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 2

	v = Is(Float64P(&myNumber1).InSlice([]MyNumber{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorFloat64PInSliceInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	_number1 := float64(1)
	number1 := &_number1

	v = Is(Float64P(number1).InSlice([]float64{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(Float64P(number1).InSlice([]float64{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 1

	v = Is(Float64P(&myNumber1).InSlice([]MyNumber{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorFloat64PNilIsValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	var valNumber *float64

	v = Is(Float64P(valNumber).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber float64
	var myNumber1 *MyNumber

	v = Is(Float64P(myNumber1).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorFloat64PNilIsInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	valNumber := float64(1)

	v = Is(Float64P(&valNumber).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber float64
	var myNumber1 MyNumber = 1

	v = Is(Float64P(&myNumber1).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])
}



func TestValidatorBytePNot(t *testing.T) {
	ResetMessages()

	number1 := byte(2)

	v := Is(ByteP(&number1).Not().EqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorBytePEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := byte(2)

	v = Is(ByteP(&number1).EqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(ByteP(&myNumber1).EqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorBytePEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := byte(2)
	number1 := &_number1

	v = Is(ByteP(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(ByteP(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(ByteP(&myNumber1).EqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorBytePGreaterThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := byte(3)

	v = Is(ByteP(&number1).GreaterThan(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(ByteP(&myNumber1).GreaterThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorBytePGreaterThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := byte(2)
	number1 := &_number1

	v = Is(ByteP(number1).GreaterThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = 2

	v = Is(ByteP(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(ByteP(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(ByteP(&myNumber1).GreaterThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorBytePGreaterOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := byte(2)

	v = Is(ByteP(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = byte(3)

	v = Is(ByteP(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(ByteP(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorBytePGreaterOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := byte(2)
	number1 := &_number1

	v = Is(ByteP(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(ByteP(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(ByteP(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorBytePLessThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := byte(2)

	v = Is(ByteP(&number1).LessThan(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(ByteP(&myNumber1).LessThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorBytePLessThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := byte(2)
	number1 := &_number1

	v = Is(ByteP(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = byte(3)

	v = Is(ByteP(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(ByteP(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(ByteP(&myNumber1).LessThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorBytePLessOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := byte(2)

	v = Is(ByteP(&number1).LessOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	v = Is(ByteP(&number1).LessOrEqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(ByteP(&myNumber1).LessOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorBytePLessOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := byte(3)
	number1 := &_number1

	v = Is(ByteP(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil
	v = Is(ByteP(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(ByteP(&myNumber1).LessOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorBytePBetweenValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := byte(2)

	v = Is(ByteP(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = byte(4)

	v = Is(ByteP(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = byte(6)

	v = Is(ByteP(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2
	var myNumber3 MyNumber = 6

	v = Is(ByteP(&myNumber1).Between(myNumber2, myNumber3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorBytePBetweenInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := byte(2)
	number1 := &_number1

	v = Is(ByteP(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = byte(7)

	v = Is(ByteP(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(ByteP(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3
	var myNumber3 MyNumber = 6

	v = Is(ByteP(&myNumber1).Between(myNumber2, myNumber3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorBytePZeroValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := byte(0)
	number1 := &_number1

	v = Is(ByteP(number1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 0

	v = Is(ByteP(&myNumber1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorBytePZeroInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := byte(1)
	number1 := &_number1

	v = Is(ByteP(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(ByteP(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 1

	v = Is(ByteP(&myNumber1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorBytePZeroOrNilValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := byte(0)
	number1 := &_number1

	v = Is(ByteP(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = nil

	v = Is(ByteP(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 0

	v = Is(ByteP(&myNumber1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorBytePZeroOrNilInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := byte(1)

	v = Is(ByteP(&number1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 1

	v = Is(ByteP(&myNumber1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorBytePPassingValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := byte(2)

	v = Is(ByteP(&number1).Passing(func(val *byte) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 2

	v = Is(ByteP(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorBytePPassingInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := byte(1)

	v = Is(ByteP(&number1).Passing(func(val *byte) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 1

	v = Is(ByteP(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorBytePInSliceValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := byte(2)

	v = Is(ByteP(&number1).InSlice([]byte{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 2

	v = Is(ByteP(&myNumber1).InSlice([]MyNumber{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorBytePInSliceInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	_number1 := byte(1)
	number1 := &_number1

	v = Is(ByteP(number1).InSlice([]byte{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(ByteP(number1).InSlice([]byte{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 1

	v = Is(ByteP(&myNumber1).InSlice([]MyNumber{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorBytePNilIsValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	var valNumber *byte

	v = Is(ByteP(valNumber).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber byte
	var myNumber1 *MyNumber

	v = Is(ByteP(myNumber1).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorBytePNilIsInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	valNumber := byte(1)

	v = Is(ByteP(&valNumber).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber byte
	var myNumber1 MyNumber = 1

	v = Is(ByteP(&myNumber1).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])
}



func TestValidatorRunePNot(t *testing.T) {
	ResetMessages()

	number1 := rune(2)

	v := Is(RuneP(&number1).Not().EqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorRunePEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := rune(2)

	v = Is(RuneP(&number1).EqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(RuneP(&myNumber1).EqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorRunePEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := rune(2)
	number1 := &_number1

	v = Is(RuneP(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(RuneP(number1).EqualTo(3))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(RuneP(&myNumber1).EqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorRunePGreaterThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := rune(3)

	v = Is(RuneP(&number1).GreaterThan(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(RuneP(&myNumber1).GreaterThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorRunePGreaterThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := rune(2)
	number1 := &_number1

	v = Is(RuneP(number1).GreaterThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = 2

	v = Is(RuneP(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(RuneP(number1).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(RuneP(&myNumber1).GreaterThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorRunePGreaterOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := rune(2)

	v = Is(RuneP(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = rune(3)

	v = Is(RuneP(&number1).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(RuneP(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorRunePGreaterOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := rune(2)
	number1 := &_number1

	v = Is(RuneP(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(RuneP(number1).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(RuneP(&myNumber1).GreaterOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorRunePLessThanValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := rune(2)

	v = Is(RuneP(&number1).LessThan(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3

	v = Is(RuneP(&myNumber1).LessThan(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorRunePLessThanInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := rune(2)
	number1 := &_number1

	v = Is(RuneP(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = rune(3)

	v = Is(RuneP(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(RuneP(number1).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(RuneP(&myNumber1).LessThan(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorRunePLessOrEqualToValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := rune(2)

	v = Is(RuneP(&number1).LessOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	v = Is(RuneP(&number1).LessOrEqualTo(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2

	v = Is(RuneP(&myNumber1).LessOrEqualTo(myNumber2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorRunePLessOrEqualToInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := rune(3)
	number1 := &_number1

	v = Is(RuneP(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil
	v = Is(RuneP(number1).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 3
	var myNumber2 MyNumber = 2

	v = Is(RuneP(&myNumber1).LessOrEqualTo(myNumber2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorRunePBetweenValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := rune(2)

	v = Is(RuneP(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = rune(4)

	v = Is(RuneP(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = rune(6)

	v = Is(RuneP(&number1).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 2
	var myNumber3 MyNumber = 6

	v = Is(RuneP(&myNumber1).Between(myNumber2, myNumber3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorRunePBetweenInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := rune(2)
	number1 := &_number1

	v = Is(RuneP(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	*number1 = rune(7)

	v = Is(RuneP(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(RuneP(number1).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 2
	var myNumber2 MyNumber = 3
	var myNumber3 MyNumber = 6

	v = Is(RuneP(&myNumber1).Between(myNumber2, myNumber3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorRunePZeroValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := rune(0)
	number1 := &_number1

	v = Is(RuneP(number1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 0

	v = Is(RuneP(&myNumber1).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorRunePZeroInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := rune(1)
	number1 := &_number1

	v = Is(RuneP(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(RuneP(number1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 1

	v = Is(RuneP(&myNumber1).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorRunePZeroOrNilValid(t *testing.T) {
	ResetMessages()
	var v *Validation

	_number1 := rune(0)
	number1 := &_number1

	v = Is(RuneP(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	number1 = nil

	v = Is(RuneP(number1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 0

	v = Is(RuneP(&myNumber1).ZeroOrNil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorRunePZeroOrNilInvalid(t *testing.T) {
	ResetMessages()
	var v *Validation

	number1 := rune(1)

	v = Is(RuneP(&number1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 1

	v = Is(RuneP(&myNumber1).ZeroOrNil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorRunePPassingValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := rune(2)

	v = Is(RuneP(&number1).Passing(func(val *rune) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 2

	v = Is(RuneP(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorRunePPassingInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := rune(1)

	v = Is(RuneP(&number1).Passing(func(val *rune) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 1

	v = Is(RuneP(&myNumber1).Passing(func(val *MyNumber) bool {
		return *val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorRunePInSliceValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	number1 := rune(2)

	v = Is(RuneP(&number1).InSlice([]rune{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 2

	v = Is(RuneP(&myNumber1).InSlice([]MyNumber{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidatorRunePInSliceInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	_number1 := rune(1)
	number1 := &_number1

	v = Is(RuneP(number1).InSlice([]rune{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	number1 = nil

	v = Is(RuneP(number1).InSlice([]rune{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 1

	v = Is(RuneP(&myNumber1).InSlice([]MyNumber{2, 3, 4}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidatorRunePNilIsValid(t *testing.T) {
	ResetMessages()

	var v *Validation

	var valNumber *rune

	v = Is(RuneP(valNumber).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type MyNumber rune
	var myNumber1 *MyNumber

	v = Is(RuneP(myNumber1).Nil())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidatorRunePNilIsInvalid(t *testing.T) {
	ResetMessages()

	var v *Validation

	valNumber := rune(1)

	v = Is(RuneP(&valNumber).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type MyNumber rune
	var myNumber1 MyNumber = 1

	v = Is(RuneP(&myNumber1).Nil())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be nil",
		v.Errors()["value_0"].Messages()[0])
}


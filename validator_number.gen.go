// Code generated by Valgo; DO NOT EDIT.
package valgo

func isUint8EqualTo[T ~uint8](v0 T, v1 T) bool {
	return v0 == v1
}
func isUint8GreaterThan[T ~uint8](v0 T, v1 T) bool {
	return v0 > v1
}
func isUint8GreaterOrEqualTo[T ~uint8](v0 T, v1 T) bool {
	return v0 >= v1
}
func isUint8LessThan[T ~uint8](v0 T, v1 T) bool {
	return v0 < v1
}
func isUint8LessOrEqualTo[T ~uint8](v0 T, v1 T) bool {
	return v0 <= v1
}
func isUint8Between[T ~uint8](v T, min T, max T) bool {
	return v >= min && v <= max
}
func isUint8Zero[T ~uint8](v T) bool {
	return v == 0
}
func isUint8InSlice[T ~uint8](v T, slice []T) bool {
	for _, _v := range slice {
		if v == _v {
			return true
		}
	}
	return false
}

// The uint8 validator type that keeps its validator context.
type ValidatorUint8[T ~uint8] struct {
	context *ValidatorContext
}

// Receives the uint8 value to validate.
//
// The value also can be a custom uint8 type such as `type Level uint8;`
//
// Optionally, the function can receive a name and title, in that order,
// to be displayed in the error messages. A `value_%N`` pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Uint8`

func Uint8[T ~uint8](value T, nameAndTitle ...string) *ValidatorUint8[T] {
	return &ValidatorUint8[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorUint8[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the logical value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	Is(v.Uint8(uint8(0)).Not().Zero()).Valid()
func (validator *ValidatorUint8[T]) Not() *ValidatorUint8[T] {
	validator.context.Not()

	return validator
}

// Validate if the uint8 value is equal to another. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := uint8(2)
//	Is(v.Uint8(quantity).Equal(uint8(2)))
func (validator *ValidatorUint8[T]) EqualTo(value T, template ...string) *ValidatorUint8[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint8EqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the uint8 value is greater than another. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := uint8(3)
//	Is(v.Uint8(quantity).GreaterThan(uint8(2)))
func (validator *ValidatorUint8[T]) GreaterThan(value T, template ...string) *ValidatorUint8[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint8GreaterThan(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the uint8 value is greater than or equal to another. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := uint8(3)
//	Is(v.Uint8(quantity).GreaterOrEqualTo(uint8(3)))
func (validator *ValidatorUint8[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorUint8[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint8GreaterOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the uint8 value is less than another. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := uint8(2)
//	Is(v.Uint8(quantity).LessThan(uint8(3)))
func (validator *ValidatorUint8[T]) LessThan(value T, template ...string) *ValidatorUint8[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint8LessThan(validator.context.Value().(T), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the uint8 value is less than or equal to another. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := uint8(2)
//	Is(v.Uint8(quantity).LessOrEqualTo(uint8(2)))
func (validator *ValidatorUint8[T]) LessOrEqualTo(value T, template ...string) *ValidatorUint8[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint8LessOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the uint8 is within a range (inclusive).
// For example:
//
//	Is(v.Uint8(uint8(3)).Between(uint8(2),uint8(6)))
func (validator *ValidatorUint8[T]) Between(min T, max T, template ...string) *ValidatorUint8[T] {
	validator.context.AddWithParams(
		func() bool {
			return isUint8Between(validator.context.Value().(T), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the uint8 value is zero.
//
// For example:
//
//	Is(v.Uint8(uint8(0)).Zero())
func (validator *ValidatorUint8[T]) Zero(template ...string) *ValidatorUint8[T] {
	validator.context.Add(
		func() bool {
			return isUint8Zero(validator.context.Value().(T))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the uint8 value passes a custom function.
// For example:
//
//	quantity := uint8(2)
//	Is(v.Uint8(quantity).Passing((v uint8) bool {
//		return v == getAllowedQuantity()
//	})
func (validator *ValidatorUint8[T]) Passing(function func(v T) bool, template ...string) *ValidatorUint8[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the uint8 value is present in the uint8 slice.
// For example:
//
//	quantity := uint8(3)
//	validQuantities := []uint8{1,3,5}
//	Is(v.Uint8(quantity).InSlice(validQuantities))
func (validator *ValidatorUint8[T]) InSlice(slice []T, template ...string) *ValidatorUint8[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint8InSlice(validator.context.Value().(T), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}
func isUint16EqualTo[T ~uint16](v0 T, v1 T) bool {
	return v0 == v1
}
func isUint16GreaterThan[T ~uint16](v0 T, v1 T) bool {
	return v0 > v1
}
func isUint16GreaterOrEqualTo[T ~uint16](v0 T, v1 T) bool {
	return v0 >= v1
}
func isUint16LessThan[T ~uint16](v0 T, v1 T) bool {
	return v0 < v1
}
func isUint16LessOrEqualTo[T ~uint16](v0 T, v1 T) bool {
	return v0 <= v1
}
func isUint16Between[T ~uint16](v T, min T, max T) bool {
	return v >= min && v <= max
}
func isUint16Zero[T ~uint16](v T) bool {
	return v == 0
}
func isUint16InSlice[T ~uint16](v T, slice []T) bool {
	for _, _v := range slice {
		if v == _v {
			return true
		}
	}
	return false
}

// The uint16 validator type that keeps its validator context.
type ValidatorUint16[T ~uint16] struct {
	context *ValidatorContext
}

// Receives the uint16 value to validate.
//
// The value also can be a custom uint16 type such as `type Level uint16;`
//
// Optionally, the function can receive a name and title, in that order,
// to be displayed in the error messages. A `value_%N`` pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Uint16`

func Uint16[T ~uint16](value T, nameAndTitle ...string) *ValidatorUint16[T] {
	return &ValidatorUint16[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorUint16[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the logical value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	Is(v.Uint16(uint16(0)).Not().Zero()).Valid()
func (validator *ValidatorUint16[T]) Not() *ValidatorUint16[T] {
	validator.context.Not()

	return validator
}

// Validate if the uint16 value is equal to another. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := uint16(2)
//	Is(v.Uint16(quantity).Equal(uint16(2)))
func (validator *ValidatorUint16[T]) EqualTo(value T, template ...string) *ValidatorUint16[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint16EqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the uint16 value is greater than another. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := uint16(3)
//	Is(v.Uint16(quantity).GreaterThan(uint16(2)))
func (validator *ValidatorUint16[T]) GreaterThan(value T, template ...string) *ValidatorUint16[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint16GreaterThan(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the uint16 value is greater than or equal to another. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := uint16(3)
//	Is(v.Uint16(quantity).GreaterOrEqualTo(uint16(3)))
func (validator *ValidatorUint16[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorUint16[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint16GreaterOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the uint16 value is less than another. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := uint16(2)
//	Is(v.Uint16(quantity).LessThan(uint16(3)))
func (validator *ValidatorUint16[T]) LessThan(value T, template ...string) *ValidatorUint16[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint16LessThan(validator.context.Value().(T), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the uint16 value is less than or equal to another. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := uint16(2)
//	Is(v.Uint16(quantity).LessOrEqualTo(uint16(2)))
func (validator *ValidatorUint16[T]) LessOrEqualTo(value T, template ...string) *ValidatorUint16[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint16LessOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the uint16 is within a range (inclusive).
// For example:
//
//	Is(v.Uint16(uint16(3)).Between(uint16(2),uint16(6)))
func (validator *ValidatorUint16[T]) Between(min T, max T, template ...string) *ValidatorUint16[T] {
	validator.context.AddWithParams(
		func() bool {
			return isUint16Between(validator.context.Value().(T), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the uint16 value is zero.
//
// For example:
//
//	Is(v.Uint16(uint16(0)).Zero())
func (validator *ValidatorUint16[T]) Zero(template ...string) *ValidatorUint16[T] {
	validator.context.Add(
		func() bool {
			return isUint16Zero(validator.context.Value().(T))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the uint16 value passes a custom function.
// For example:
//
//	quantity := uint16(2)
//	Is(v.Uint16(quantity).Passing((v uint16) bool {
//		return v == getAllowedQuantity()
//	})
func (validator *ValidatorUint16[T]) Passing(function func(v T) bool, template ...string) *ValidatorUint16[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the uint16 value is present in the uint16 slice.
// For example:
//
//	quantity := uint16(3)
//	validQuantities := []uint16{1,3,5}
//	Is(v.Uint16(quantity).InSlice(validQuantities))
func (validator *ValidatorUint16[T]) InSlice(slice []T, template ...string) *ValidatorUint16[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint16InSlice(validator.context.Value().(T), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}
func isUint32EqualTo[T ~uint32](v0 T, v1 T) bool {
	return v0 == v1
}
func isUint32GreaterThan[T ~uint32](v0 T, v1 T) bool {
	return v0 > v1
}
func isUint32GreaterOrEqualTo[T ~uint32](v0 T, v1 T) bool {
	return v0 >= v1
}
func isUint32LessThan[T ~uint32](v0 T, v1 T) bool {
	return v0 < v1
}
func isUint32LessOrEqualTo[T ~uint32](v0 T, v1 T) bool {
	return v0 <= v1
}
func isUint32Between[T ~uint32](v T, min T, max T) bool {
	return v >= min && v <= max
}
func isUint32Zero[T ~uint32](v T) bool {
	return v == 0
}
func isUint32InSlice[T ~uint32](v T, slice []T) bool {
	for _, _v := range slice {
		if v == _v {
			return true
		}
	}
	return false
}

// The uint32 validator type that keeps its validator context.
type ValidatorUint32[T ~uint32] struct {
	context *ValidatorContext
}

// Receives the uint32 value to validate.
//
// The value also can be a custom uint32 type such as `type Level uint32;`
//
// Optionally, the function can receive a name and title, in that order,
// to be displayed in the error messages. A `value_%N`` pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Uint32`

func Uint32[T ~uint32](value T, nameAndTitle ...string) *ValidatorUint32[T] {
	return &ValidatorUint32[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorUint32[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the logical value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	Is(v.Uint32(uint32(0)).Not().Zero()).Valid()
func (validator *ValidatorUint32[T]) Not() *ValidatorUint32[T] {
	validator.context.Not()

	return validator
}

// Validate if the uint32 value is equal to another. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := uint32(2)
//	Is(v.Uint32(quantity).Equal(uint32(2)))
func (validator *ValidatorUint32[T]) EqualTo(value T, template ...string) *ValidatorUint32[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint32EqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the uint32 value is greater than another. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := uint32(3)
//	Is(v.Uint32(quantity).GreaterThan(uint32(2)))
func (validator *ValidatorUint32[T]) GreaterThan(value T, template ...string) *ValidatorUint32[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint32GreaterThan(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the uint32 value is greater than or equal to another. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := uint32(3)
//	Is(v.Uint32(quantity).GreaterOrEqualTo(uint32(3)))
func (validator *ValidatorUint32[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorUint32[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint32GreaterOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the uint32 value is less than another. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := uint32(2)
//	Is(v.Uint32(quantity).LessThan(uint32(3)))
func (validator *ValidatorUint32[T]) LessThan(value T, template ...string) *ValidatorUint32[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint32LessThan(validator.context.Value().(T), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the uint32 value is less than or equal to another. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := uint32(2)
//	Is(v.Uint32(quantity).LessOrEqualTo(uint32(2)))
func (validator *ValidatorUint32[T]) LessOrEqualTo(value T, template ...string) *ValidatorUint32[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint32LessOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the uint32 is within a range (inclusive).
// For example:
//
//	Is(v.Uint32(uint32(3)).Between(uint32(2),uint32(6)))
func (validator *ValidatorUint32[T]) Between(min T, max T, template ...string) *ValidatorUint32[T] {
	validator.context.AddWithParams(
		func() bool {
			return isUint32Between(validator.context.Value().(T), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the uint32 value is zero.
//
// For example:
//
//	Is(v.Uint32(uint32(0)).Zero())
func (validator *ValidatorUint32[T]) Zero(template ...string) *ValidatorUint32[T] {
	validator.context.Add(
		func() bool {
			return isUint32Zero(validator.context.Value().(T))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the uint32 value passes a custom function.
// For example:
//
//	quantity := uint32(2)
//	Is(v.Uint32(quantity).Passing((v uint32) bool {
//		return v == getAllowedQuantity()
//	})
func (validator *ValidatorUint32[T]) Passing(function func(v T) bool, template ...string) *ValidatorUint32[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the uint32 value is present in the uint32 slice.
// For example:
//
//	quantity := uint32(3)
//	validQuantities := []uint32{1,3,5}
//	Is(v.Uint32(quantity).InSlice(validQuantities))
func (validator *ValidatorUint32[T]) InSlice(slice []T, template ...string) *ValidatorUint32[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint32InSlice(validator.context.Value().(T), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}
func isUint64EqualTo[T ~uint64](v0 T, v1 T) bool {
	return v0 == v1
}
func isUint64GreaterThan[T ~uint64](v0 T, v1 T) bool {
	return v0 > v1
}
func isUint64GreaterOrEqualTo[T ~uint64](v0 T, v1 T) bool {
	return v0 >= v1
}
func isUint64LessThan[T ~uint64](v0 T, v1 T) bool {
	return v0 < v1
}
func isUint64LessOrEqualTo[T ~uint64](v0 T, v1 T) bool {
	return v0 <= v1
}
func isUint64Between[T ~uint64](v T, min T, max T) bool {
	return v >= min && v <= max
}
func isUint64Zero[T ~uint64](v T) bool {
	return v == 0
}
func isUint64InSlice[T ~uint64](v T, slice []T) bool {
	for _, _v := range slice {
		if v == _v {
			return true
		}
	}
	return false
}

// The uint64 validator type that keeps its validator context.
type ValidatorUint64[T ~uint64] struct {
	context *ValidatorContext
}

// Receives the uint64 value to validate.
//
// The value also can be a custom uint64 type such as `type Level uint64;`
//
// Optionally, the function can receive a name and title, in that order,
// to be displayed in the error messages. A `value_%N`` pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Uint64`

func Uint64[T ~uint64](value T, nameAndTitle ...string) *ValidatorUint64[T] {
	return &ValidatorUint64[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorUint64[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the logical value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	Is(v.Uint64(uint64(0)).Not().Zero()).Valid()
func (validator *ValidatorUint64[T]) Not() *ValidatorUint64[T] {
	validator.context.Not()

	return validator
}

// Validate if the uint64 value is equal to another. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := uint64(2)
//	Is(v.Uint64(quantity).Equal(uint64(2)))
func (validator *ValidatorUint64[T]) EqualTo(value T, template ...string) *ValidatorUint64[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint64EqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the uint64 value is greater than another. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := uint64(3)
//	Is(v.Uint64(quantity).GreaterThan(uint64(2)))
func (validator *ValidatorUint64[T]) GreaterThan(value T, template ...string) *ValidatorUint64[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint64GreaterThan(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the uint64 value is greater than or equal to another. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := uint64(3)
//	Is(v.Uint64(quantity).GreaterOrEqualTo(uint64(3)))
func (validator *ValidatorUint64[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorUint64[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint64GreaterOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the uint64 value is less than another. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := uint64(2)
//	Is(v.Uint64(quantity).LessThan(uint64(3)))
func (validator *ValidatorUint64[T]) LessThan(value T, template ...string) *ValidatorUint64[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint64LessThan(validator.context.Value().(T), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the uint64 value is less than or equal to another. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := uint64(2)
//	Is(v.Uint64(quantity).LessOrEqualTo(uint64(2)))
func (validator *ValidatorUint64[T]) LessOrEqualTo(value T, template ...string) *ValidatorUint64[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint64LessOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the uint64 is within a range (inclusive).
// For example:
//
//	Is(v.Uint64(uint64(3)).Between(uint64(2),uint64(6)))
func (validator *ValidatorUint64[T]) Between(min T, max T, template ...string) *ValidatorUint64[T] {
	validator.context.AddWithParams(
		func() bool {
			return isUint64Between(validator.context.Value().(T), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the uint64 value is zero.
//
// For example:
//
//	Is(v.Uint64(uint64(0)).Zero())
func (validator *ValidatorUint64[T]) Zero(template ...string) *ValidatorUint64[T] {
	validator.context.Add(
		func() bool {
			return isUint64Zero(validator.context.Value().(T))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the uint64 value passes a custom function.
// For example:
//
//	quantity := uint64(2)
//	Is(v.Uint64(quantity).Passing((v uint64) bool {
//		return v == getAllowedQuantity()
//	})
func (validator *ValidatorUint64[T]) Passing(function func(v T) bool, template ...string) *ValidatorUint64[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the uint64 value is present in the uint64 slice.
// For example:
//
//	quantity := uint64(3)
//	validQuantities := []uint64{1,3,5}
//	Is(v.Uint64(quantity).InSlice(validQuantities))
func (validator *ValidatorUint64[T]) InSlice(slice []T, template ...string) *ValidatorUint64[T] {
	validator.context.AddWithValue(
		func() bool {
			return isUint64InSlice(validator.context.Value().(T), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}
func isIntEqualTo[T ~int](v0 T, v1 T) bool {
	return v0 == v1
}
func isIntGreaterThan[T ~int](v0 T, v1 T) bool {
	return v0 > v1
}
func isIntGreaterOrEqualTo[T ~int](v0 T, v1 T) bool {
	return v0 >= v1
}
func isIntLessThan[T ~int](v0 T, v1 T) bool {
	return v0 < v1
}
func isIntLessOrEqualTo[T ~int](v0 T, v1 T) bool {
	return v0 <= v1
}
func isIntBetween[T ~int](v T, min T, max T) bool {
	return v >= min && v <= max
}
func isIntZero[T ~int](v T) bool {
	return v == 0
}
func isIntInSlice[T ~int](v T, slice []T) bool {
	for _, _v := range slice {
		if v == _v {
			return true
		}
	}
	return false
}

// The int validator type that keeps its validator context.
type ValidatorInt[T ~int] struct {
	context *ValidatorContext
}

// Receives the int value to validate.
//
// The value also can be a custom int type such as `type Level int;`
//
// Optionally, the function can receive a name and title, in that order,
// to be displayed in the error messages. A `value_%N`` pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Int`

func Int[T ~int](value T, nameAndTitle ...string) *ValidatorInt[T] {
	return &ValidatorInt[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorInt[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the logical value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	Is(v.Int(int(0)).Not().Zero()).Valid()
func (validator *ValidatorInt[T]) Not() *ValidatorInt[T] {
	validator.context.Not()

	return validator
}

// Validate if the int value is equal to another. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := int(2)
//	Is(v.Int(quantity).Equal(int(2)))
func (validator *ValidatorInt[T]) EqualTo(value T, template ...string) *ValidatorInt[T] {
	validator.context.AddWithValue(
		func() bool {
			return isIntEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the int value is greater than another. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := int(3)
//	Is(v.Int(quantity).GreaterThan(int(2)))
func (validator *ValidatorInt[T]) GreaterThan(value T, template ...string) *ValidatorInt[T] {
	validator.context.AddWithValue(
		func() bool {
			return isIntGreaterThan(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the int value is greater than or equal to another. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := int(3)
//	Is(v.Int(quantity).GreaterOrEqualTo(int(3)))
func (validator *ValidatorInt[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorInt[T] {
	validator.context.AddWithValue(
		func() bool {
			return isIntGreaterOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the int value is less than another. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := int(2)
//	Is(v.Int(quantity).LessThan(int(3)))
func (validator *ValidatorInt[T]) LessThan(value T, template ...string) *ValidatorInt[T] {
	validator.context.AddWithValue(
		func() bool {
			return isIntLessThan(validator.context.Value().(T), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the int value is less than or equal to another. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := int(2)
//	Is(v.Int(quantity).LessOrEqualTo(int(2)))
func (validator *ValidatorInt[T]) LessOrEqualTo(value T, template ...string) *ValidatorInt[T] {
	validator.context.AddWithValue(
		func() bool {
			return isIntLessOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the int is within a range (inclusive).
// For example:
//
//	Is(v.Int(int(3)).Between(int(2),int(6)))
func (validator *ValidatorInt[T]) Between(min T, max T, template ...string) *ValidatorInt[T] {
	validator.context.AddWithParams(
		func() bool {
			return isIntBetween(validator.context.Value().(T), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the int value is zero.
//
// For example:
//
//	Is(v.Int(int(0)).Zero())
func (validator *ValidatorInt[T]) Zero(template ...string) *ValidatorInt[T] {
	validator.context.Add(
		func() bool {
			return isIntZero(validator.context.Value().(T))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the int value passes a custom function.
// For example:
//
//	quantity := int(2)
//	Is(v.Int(quantity).Passing((v int) bool {
//		return v == getAllowedQuantity()
//	})
func (validator *ValidatorInt[T]) Passing(function func(v T) bool, template ...string) *ValidatorInt[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the int value is present in the int slice.
// For example:
//
//	quantity := int(3)
//	validQuantities := []int{1,3,5}
//	Is(v.Int(quantity).InSlice(validQuantities))
func (validator *ValidatorInt[T]) InSlice(slice []T, template ...string) *ValidatorInt[T] {
	validator.context.AddWithValue(
		func() bool {
			return isIntInSlice(validator.context.Value().(T), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}
func isInt8EqualTo[T ~int8](v0 T, v1 T) bool {
	return v0 == v1
}
func isInt8GreaterThan[T ~int8](v0 T, v1 T) bool {
	return v0 > v1
}
func isInt8GreaterOrEqualTo[T ~int8](v0 T, v1 T) bool {
	return v0 >= v1
}
func isInt8LessThan[T ~int8](v0 T, v1 T) bool {
	return v0 < v1
}
func isInt8LessOrEqualTo[T ~int8](v0 T, v1 T) bool {
	return v0 <= v1
}
func isInt8Between[T ~int8](v T, min T, max T) bool {
	return v >= min && v <= max
}
func isInt8Zero[T ~int8](v T) bool {
	return v == 0
}
func isInt8InSlice[T ~int8](v T, slice []T) bool {
	for _, _v := range slice {
		if v == _v {
			return true
		}
	}
	return false
}

// The int8 validator type that keeps its validator context.
type ValidatorInt8[T ~int8] struct {
	context *ValidatorContext
}

// Receives the int8 value to validate.
//
// The value also can be a custom int8 type such as `type Level int8;`
//
// Optionally, the function can receive a name and title, in that order,
// to be displayed in the error messages. A `value_%N`` pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Int8`

func Int8[T ~int8](value T, nameAndTitle ...string) *ValidatorInt8[T] {
	return &ValidatorInt8[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorInt8[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the logical value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	Is(v.Int8(int8(0)).Not().Zero()).Valid()
func (validator *ValidatorInt8[T]) Not() *ValidatorInt8[T] {
	validator.context.Not()

	return validator
}

// Validate if the int8 value is equal to another. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := int8(2)
//	Is(v.Int8(quantity).Equal(int8(2)))
func (validator *ValidatorInt8[T]) EqualTo(value T, template ...string) *ValidatorInt8[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt8EqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the int8 value is greater than another. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := int8(3)
//	Is(v.Int8(quantity).GreaterThan(int8(2)))
func (validator *ValidatorInt8[T]) GreaterThan(value T, template ...string) *ValidatorInt8[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt8GreaterThan(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the int8 value is greater than or equal to another. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := int8(3)
//	Is(v.Int8(quantity).GreaterOrEqualTo(int8(3)))
func (validator *ValidatorInt8[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorInt8[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt8GreaterOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the int8 value is less than another. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := int8(2)
//	Is(v.Int8(quantity).LessThan(int8(3)))
func (validator *ValidatorInt8[T]) LessThan(value T, template ...string) *ValidatorInt8[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt8LessThan(validator.context.Value().(T), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the int8 value is less than or equal to another. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := int8(2)
//	Is(v.Int8(quantity).LessOrEqualTo(int8(2)))
func (validator *ValidatorInt8[T]) LessOrEqualTo(value T, template ...string) *ValidatorInt8[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt8LessOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the int8 is within a range (inclusive).
// For example:
//
//	Is(v.Int8(int8(3)).Between(int8(2),int8(6)))
func (validator *ValidatorInt8[T]) Between(min T, max T, template ...string) *ValidatorInt8[T] {
	validator.context.AddWithParams(
		func() bool {
			return isInt8Between(validator.context.Value().(T), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the int8 value is zero.
//
// For example:
//
//	Is(v.Int8(int8(0)).Zero())
func (validator *ValidatorInt8[T]) Zero(template ...string) *ValidatorInt8[T] {
	validator.context.Add(
		func() bool {
			return isInt8Zero(validator.context.Value().(T))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the int8 value passes a custom function.
// For example:
//
//	quantity := int8(2)
//	Is(v.Int8(quantity).Passing((v int8) bool {
//		return v == getAllowedQuantity()
//	})
func (validator *ValidatorInt8[T]) Passing(function func(v T) bool, template ...string) *ValidatorInt8[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the int8 value is present in the int8 slice.
// For example:
//
//	quantity := int8(3)
//	validQuantities := []int8{1,3,5}
//	Is(v.Int8(quantity).InSlice(validQuantities))
func (validator *ValidatorInt8[T]) InSlice(slice []T, template ...string) *ValidatorInt8[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt8InSlice(validator.context.Value().(T), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}
func isInt16EqualTo[T ~int16](v0 T, v1 T) bool {
	return v0 == v1
}
func isInt16GreaterThan[T ~int16](v0 T, v1 T) bool {
	return v0 > v1
}
func isInt16GreaterOrEqualTo[T ~int16](v0 T, v1 T) bool {
	return v0 >= v1
}
func isInt16LessThan[T ~int16](v0 T, v1 T) bool {
	return v0 < v1
}
func isInt16LessOrEqualTo[T ~int16](v0 T, v1 T) bool {
	return v0 <= v1
}
func isInt16Between[T ~int16](v T, min T, max T) bool {
	return v >= min && v <= max
}
func isInt16Zero[T ~int16](v T) bool {
	return v == 0
}
func isInt16InSlice[T ~int16](v T, slice []T) bool {
	for _, _v := range slice {
		if v == _v {
			return true
		}
	}
	return false
}

// The int16 validator type that keeps its validator context.
type ValidatorInt16[T ~int16] struct {
	context *ValidatorContext
}

// Receives the int16 value to validate.
//
// The value also can be a custom int16 type such as `type Level int16;`
//
// Optionally, the function can receive a name and title, in that order,
// to be displayed in the error messages. A `value_%N`` pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Int16`

func Int16[T ~int16](value T, nameAndTitle ...string) *ValidatorInt16[T] {
	return &ValidatorInt16[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorInt16[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the logical value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	Is(v.Int16(int16(0)).Not().Zero()).Valid()
func (validator *ValidatorInt16[T]) Not() *ValidatorInt16[T] {
	validator.context.Not()

	return validator
}

// Validate if the int16 value is equal to another. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := int16(2)
//	Is(v.Int16(quantity).Equal(int16(2)))
func (validator *ValidatorInt16[T]) EqualTo(value T, template ...string) *ValidatorInt16[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt16EqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the int16 value is greater than another. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := int16(3)
//	Is(v.Int16(quantity).GreaterThan(int16(2)))
func (validator *ValidatorInt16[T]) GreaterThan(value T, template ...string) *ValidatorInt16[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt16GreaterThan(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the int16 value is greater than or equal to another. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := int16(3)
//	Is(v.Int16(quantity).GreaterOrEqualTo(int16(3)))
func (validator *ValidatorInt16[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorInt16[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt16GreaterOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the int16 value is less than another. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := int16(2)
//	Is(v.Int16(quantity).LessThan(int16(3)))
func (validator *ValidatorInt16[T]) LessThan(value T, template ...string) *ValidatorInt16[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt16LessThan(validator.context.Value().(T), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the int16 value is less than or equal to another. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := int16(2)
//	Is(v.Int16(quantity).LessOrEqualTo(int16(2)))
func (validator *ValidatorInt16[T]) LessOrEqualTo(value T, template ...string) *ValidatorInt16[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt16LessOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the int16 is within a range (inclusive).
// For example:
//
//	Is(v.Int16(int16(3)).Between(int16(2),int16(6)))
func (validator *ValidatorInt16[T]) Between(min T, max T, template ...string) *ValidatorInt16[T] {
	validator.context.AddWithParams(
		func() bool {
			return isInt16Between(validator.context.Value().(T), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the int16 value is zero.
//
// For example:
//
//	Is(v.Int16(int16(0)).Zero())
func (validator *ValidatorInt16[T]) Zero(template ...string) *ValidatorInt16[T] {
	validator.context.Add(
		func() bool {
			return isInt16Zero(validator.context.Value().(T))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the int16 value passes a custom function.
// For example:
//
//	quantity := int16(2)
//	Is(v.Int16(quantity).Passing((v int16) bool {
//		return v == getAllowedQuantity()
//	})
func (validator *ValidatorInt16[T]) Passing(function func(v T) bool, template ...string) *ValidatorInt16[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the int16 value is present in the int16 slice.
// For example:
//
//	quantity := int16(3)
//	validQuantities := []int16{1,3,5}
//	Is(v.Int16(quantity).InSlice(validQuantities))
func (validator *ValidatorInt16[T]) InSlice(slice []T, template ...string) *ValidatorInt16[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt16InSlice(validator.context.Value().(T), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}
func isInt32EqualTo[T ~int32](v0 T, v1 T) bool {
	return v0 == v1
}
func isInt32GreaterThan[T ~int32](v0 T, v1 T) bool {
	return v0 > v1
}
func isInt32GreaterOrEqualTo[T ~int32](v0 T, v1 T) bool {
	return v0 >= v1
}
func isInt32LessThan[T ~int32](v0 T, v1 T) bool {
	return v0 < v1
}
func isInt32LessOrEqualTo[T ~int32](v0 T, v1 T) bool {
	return v0 <= v1
}
func isInt32Between[T ~int32](v T, min T, max T) bool {
	return v >= min && v <= max
}
func isInt32Zero[T ~int32](v T) bool {
	return v == 0
}
func isInt32InSlice[T ~int32](v T, slice []T) bool {
	for _, _v := range slice {
		if v == _v {
			return true
		}
	}
	return false
}

// The int32 validator type that keeps its validator context.
type ValidatorInt32[T ~int32] struct {
	context *ValidatorContext
}

// Receives the int32 value to validate.
//
// The value also can be a custom int32 type such as `type Level int32;`
//
// Optionally, the function can receive a name and title, in that order,
// to be displayed in the error messages. A `value_%N`` pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Int32`

func Int32[T ~int32](value T, nameAndTitle ...string) *ValidatorInt32[T] {
	return &ValidatorInt32[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorInt32[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the logical value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	Is(v.Int32(int32(0)).Not().Zero()).Valid()
func (validator *ValidatorInt32[T]) Not() *ValidatorInt32[T] {
	validator.context.Not()

	return validator
}

// Validate if the int32 value is equal to another. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := int32(2)
//	Is(v.Int32(quantity).Equal(int32(2)))
func (validator *ValidatorInt32[T]) EqualTo(value T, template ...string) *ValidatorInt32[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt32EqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the int32 value is greater than another. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := int32(3)
//	Is(v.Int32(quantity).GreaterThan(int32(2)))
func (validator *ValidatorInt32[T]) GreaterThan(value T, template ...string) *ValidatorInt32[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt32GreaterThan(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the int32 value is greater than or equal to another. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := int32(3)
//	Is(v.Int32(quantity).GreaterOrEqualTo(int32(3)))
func (validator *ValidatorInt32[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorInt32[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt32GreaterOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the int32 value is less than another. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := int32(2)
//	Is(v.Int32(quantity).LessThan(int32(3)))
func (validator *ValidatorInt32[T]) LessThan(value T, template ...string) *ValidatorInt32[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt32LessThan(validator.context.Value().(T), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the int32 value is less than or equal to another. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := int32(2)
//	Is(v.Int32(quantity).LessOrEqualTo(int32(2)))
func (validator *ValidatorInt32[T]) LessOrEqualTo(value T, template ...string) *ValidatorInt32[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt32LessOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the int32 is within a range (inclusive).
// For example:
//
//	Is(v.Int32(int32(3)).Between(int32(2),int32(6)))
func (validator *ValidatorInt32[T]) Between(min T, max T, template ...string) *ValidatorInt32[T] {
	validator.context.AddWithParams(
		func() bool {
			return isInt32Between(validator.context.Value().(T), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the int32 value is zero.
//
// For example:
//
//	Is(v.Int32(int32(0)).Zero())
func (validator *ValidatorInt32[T]) Zero(template ...string) *ValidatorInt32[T] {
	validator.context.Add(
		func() bool {
			return isInt32Zero(validator.context.Value().(T))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the int32 value passes a custom function.
// For example:
//
//	quantity := int32(2)
//	Is(v.Int32(quantity).Passing((v int32) bool {
//		return v == getAllowedQuantity()
//	})
func (validator *ValidatorInt32[T]) Passing(function func(v T) bool, template ...string) *ValidatorInt32[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the int32 value is present in the int32 slice.
// For example:
//
//	quantity := int32(3)
//	validQuantities := []int32{1,3,5}
//	Is(v.Int32(quantity).InSlice(validQuantities))
func (validator *ValidatorInt32[T]) InSlice(slice []T, template ...string) *ValidatorInt32[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt32InSlice(validator.context.Value().(T), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}
func isInt64EqualTo[T ~int64](v0 T, v1 T) bool {
	return v0 == v1
}
func isInt64GreaterThan[T ~int64](v0 T, v1 T) bool {
	return v0 > v1
}
func isInt64GreaterOrEqualTo[T ~int64](v0 T, v1 T) bool {
	return v0 >= v1
}
func isInt64LessThan[T ~int64](v0 T, v1 T) bool {
	return v0 < v1
}
func isInt64LessOrEqualTo[T ~int64](v0 T, v1 T) bool {
	return v0 <= v1
}
func isInt64Between[T ~int64](v T, min T, max T) bool {
	return v >= min && v <= max
}
func isInt64Zero[T ~int64](v T) bool {
	return v == 0
}
func isInt64InSlice[T ~int64](v T, slice []T) bool {
	for _, _v := range slice {
		if v == _v {
			return true
		}
	}
	return false
}

// The int64 validator type that keeps its validator context.
type ValidatorInt64[T ~int64] struct {
	context *ValidatorContext
}

// Receives the int64 value to validate.
//
// The value also can be a custom int64 type such as `type Level int64;`
//
// Optionally, the function can receive a name and title, in that order,
// to be displayed in the error messages. A `value_%N`` pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Int64`

func Int64[T ~int64](value T, nameAndTitle ...string) *ValidatorInt64[T] {
	return &ValidatorInt64[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorInt64[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the logical value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	Is(v.Int64(int64(0)).Not().Zero()).Valid()
func (validator *ValidatorInt64[T]) Not() *ValidatorInt64[T] {
	validator.context.Not()

	return validator
}

// Validate if the int64 value is equal to another. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := int64(2)
//	Is(v.Int64(quantity).Equal(int64(2)))
func (validator *ValidatorInt64[T]) EqualTo(value T, template ...string) *ValidatorInt64[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt64EqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the int64 value is greater than another. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := int64(3)
//	Is(v.Int64(quantity).GreaterThan(int64(2)))
func (validator *ValidatorInt64[T]) GreaterThan(value T, template ...string) *ValidatorInt64[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt64GreaterThan(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the int64 value is greater than or equal to another. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := int64(3)
//	Is(v.Int64(quantity).GreaterOrEqualTo(int64(3)))
func (validator *ValidatorInt64[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorInt64[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt64GreaterOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the int64 value is less than another. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := int64(2)
//	Is(v.Int64(quantity).LessThan(int64(3)))
func (validator *ValidatorInt64[T]) LessThan(value T, template ...string) *ValidatorInt64[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt64LessThan(validator.context.Value().(T), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the int64 value is less than or equal to another. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := int64(2)
//	Is(v.Int64(quantity).LessOrEqualTo(int64(2)))
func (validator *ValidatorInt64[T]) LessOrEqualTo(value T, template ...string) *ValidatorInt64[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt64LessOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the int64 is within a range (inclusive).
// For example:
//
//	Is(v.Int64(int64(3)).Between(int64(2),int64(6)))
func (validator *ValidatorInt64[T]) Between(min T, max T, template ...string) *ValidatorInt64[T] {
	validator.context.AddWithParams(
		func() bool {
			return isInt64Between(validator.context.Value().(T), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the int64 value is zero.
//
// For example:
//
//	Is(v.Int64(int64(0)).Zero())
func (validator *ValidatorInt64[T]) Zero(template ...string) *ValidatorInt64[T] {
	validator.context.Add(
		func() bool {
			return isInt64Zero(validator.context.Value().(T))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the int64 value passes a custom function.
// For example:
//
//	quantity := int64(2)
//	Is(v.Int64(quantity).Passing((v int64) bool {
//		return v == getAllowedQuantity()
//	})
func (validator *ValidatorInt64[T]) Passing(function func(v T) bool, template ...string) *ValidatorInt64[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the int64 value is present in the int64 slice.
// For example:
//
//	quantity := int64(3)
//	validQuantities := []int64{1,3,5}
//	Is(v.Int64(quantity).InSlice(validQuantities))
func (validator *ValidatorInt64[T]) InSlice(slice []T, template ...string) *ValidatorInt64[T] {
	validator.context.AddWithValue(
		func() bool {
			return isInt64InSlice(validator.context.Value().(T), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}
func isFloat32EqualTo[T ~float32](v0 T, v1 T) bool {
	return v0 == v1
}
func isFloat32GreaterThan[T ~float32](v0 T, v1 T) bool {
	return v0 > v1
}
func isFloat32GreaterOrEqualTo[T ~float32](v0 T, v1 T) bool {
	return v0 >= v1
}
func isFloat32LessThan[T ~float32](v0 T, v1 T) bool {
	return v0 < v1
}
func isFloat32LessOrEqualTo[T ~float32](v0 T, v1 T) bool {
	return v0 <= v1
}
func isFloat32Between[T ~float32](v T, min T, max T) bool {
	return v >= min && v <= max
}
func isFloat32Zero[T ~float32](v T) bool {
	return v == 0
}
func isFloat32InSlice[T ~float32](v T, slice []T) bool {
	for _, _v := range slice {
		if v == _v {
			return true
		}
	}
	return false
}

// The float32 validator type that keeps its validator context.
type ValidatorFloat32[T ~float32] struct {
	context *ValidatorContext
}

// Receives the float32 value to validate.
//
// The value also can be a custom float32 type such as `type Level float32;`
//
// Optionally, the function can receive a name and title, in that order,
// to be displayed in the error messages. A `value_%N`` pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Float32`

func Float32[T ~float32](value T, nameAndTitle ...string) *ValidatorFloat32[T] {
	return &ValidatorFloat32[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorFloat32[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the logical value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	Is(v.Float32(float32(0)).Not().Zero()).Valid()
func (validator *ValidatorFloat32[T]) Not() *ValidatorFloat32[T] {
	validator.context.Not()

	return validator
}

// Validate if the float32 value is equal to another. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := float32(2)
//	Is(v.Float32(quantity).Equal(float32(2)))
func (validator *ValidatorFloat32[T]) EqualTo(value T, template ...string) *ValidatorFloat32[T] {
	validator.context.AddWithValue(
		func() bool {
			return isFloat32EqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the float32 value is greater than another. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := float32(3)
//	Is(v.Float32(quantity).GreaterThan(float32(2)))
func (validator *ValidatorFloat32[T]) GreaterThan(value T, template ...string) *ValidatorFloat32[T] {
	validator.context.AddWithValue(
		func() bool {
			return isFloat32GreaterThan(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the float32 value is greater than or equal to another. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := float32(3)
//	Is(v.Float32(quantity).GreaterOrEqualTo(float32(3)))
func (validator *ValidatorFloat32[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorFloat32[T] {
	validator.context.AddWithValue(
		func() bool {
			return isFloat32GreaterOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the float32 value is less than another. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := float32(2)
//	Is(v.Float32(quantity).LessThan(float32(3)))
func (validator *ValidatorFloat32[T]) LessThan(value T, template ...string) *ValidatorFloat32[T] {
	validator.context.AddWithValue(
		func() bool {
			return isFloat32LessThan(validator.context.Value().(T), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the float32 value is less than or equal to another. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := float32(2)
//	Is(v.Float32(quantity).LessOrEqualTo(float32(2)))
func (validator *ValidatorFloat32[T]) LessOrEqualTo(value T, template ...string) *ValidatorFloat32[T] {
	validator.context.AddWithValue(
		func() bool {
			return isFloat32LessOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the float32 is within a range (inclusive).
// For example:
//
//	Is(v.Float32(float32(3)).Between(float32(2),float32(6)))
func (validator *ValidatorFloat32[T]) Between(min T, max T, template ...string) *ValidatorFloat32[T] {
	validator.context.AddWithParams(
		func() bool {
			return isFloat32Between(validator.context.Value().(T), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the float32 value is zero.
//
// For example:
//
//	Is(v.Float32(float32(0)).Zero())
func (validator *ValidatorFloat32[T]) Zero(template ...string) *ValidatorFloat32[T] {
	validator.context.Add(
		func() bool {
			return isFloat32Zero(validator.context.Value().(T))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the float32 value passes a custom function.
// For example:
//
//	quantity := float32(2)
//	Is(v.Float32(quantity).Passing((v float32) bool {
//		return v == getAllowedQuantity()
//	})
func (validator *ValidatorFloat32[T]) Passing(function func(v T) bool, template ...string) *ValidatorFloat32[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the float32 value is present in the float32 slice.
// For example:
//
//	quantity := float32(3)
//	validQuantities := []float32{1,3,5}
//	Is(v.Float32(quantity).InSlice(validQuantities))
func (validator *ValidatorFloat32[T]) InSlice(slice []T, template ...string) *ValidatorFloat32[T] {
	validator.context.AddWithValue(
		func() bool {
			return isFloat32InSlice(validator.context.Value().(T), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}
func isFloat64EqualTo[T ~float64](v0 T, v1 T) bool {
	return v0 == v1
}
func isFloat64GreaterThan[T ~float64](v0 T, v1 T) bool {
	return v0 > v1
}
func isFloat64GreaterOrEqualTo[T ~float64](v0 T, v1 T) bool {
	return v0 >= v1
}
func isFloat64LessThan[T ~float64](v0 T, v1 T) bool {
	return v0 < v1
}
func isFloat64LessOrEqualTo[T ~float64](v0 T, v1 T) bool {
	return v0 <= v1
}
func isFloat64Between[T ~float64](v T, min T, max T) bool {
	return v >= min && v <= max
}
func isFloat64Zero[T ~float64](v T) bool {
	return v == 0
}
func isFloat64InSlice[T ~float64](v T, slice []T) bool {
	for _, _v := range slice {
		if v == _v {
			return true
		}
	}
	return false
}

// The float64 validator type that keeps its validator context.
type ValidatorFloat64[T ~float64] struct {
	context *ValidatorContext
}

// Receives the float64 value to validate.
//
// The value also can be a custom float64 type such as `type Level float64;`
//
// Optionally, the function can receive a name and title, in that order,
// to be displayed in the error messages. A `value_%N`` pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Float64`

func Float64[T ~float64](value T, nameAndTitle ...string) *ValidatorFloat64[T] {
	return &ValidatorFloat64[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorFloat64[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the logical value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	Is(v.Float64(float64(0)).Not().Zero()).Valid()
func (validator *ValidatorFloat64[T]) Not() *ValidatorFloat64[T] {
	validator.context.Not()

	return validator
}

// Validate if the float64 value is equal to another. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := float64(2)
//	Is(v.Float64(quantity).Equal(float64(2)))
func (validator *ValidatorFloat64[T]) EqualTo(value T, template ...string) *ValidatorFloat64[T] {
	validator.context.AddWithValue(
		func() bool {
			return isFloat64EqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the float64 value is greater than another. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := float64(3)
//	Is(v.Float64(quantity).GreaterThan(float64(2)))
func (validator *ValidatorFloat64[T]) GreaterThan(value T, template ...string) *ValidatorFloat64[T] {
	validator.context.AddWithValue(
		func() bool {
			return isFloat64GreaterThan(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the float64 value is greater than or equal to another. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := float64(3)
//	Is(v.Float64(quantity).GreaterOrEqualTo(float64(3)))
func (validator *ValidatorFloat64[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorFloat64[T] {
	validator.context.AddWithValue(
		func() bool {
			return isFloat64GreaterOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the float64 value is less than another. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := float64(2)
//	Is(v.Float64(quantity).LessThan(float64(3)))
func (validator *ValidatorFloat64[T]) LessThan(value T, template ...string) *ValidatorFloat64[T] {
	validator.context.AddWithValue(
		func() bool {
			return isFloat64LessThan(validator.context.Value().(T), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the float64 value is less than or equal to another. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := float64(2)
//	Is(v.Float64(quantity).LessOrEqualTo(float64(2)))
func (validator *ValidatorFloat64[T]) LessOrEqualTo(value T, template ...string) *ValidatorFloat64[T] {
	validator.context.AddWithValue(
		func() bool {
			return isFloat64LessOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the float64 is within a range (inclusive).
// For example:
//
//	Is(v.Float64(float64(3)).Between(float64(2),float64(6)))
func (validator *ValidatorFloat64[T]) Between(min T, max T, template ...string) *ValidatorFloat64[T] {
	validator.context.AddWithParams(
		func() bool {
			return isFloat64Between(validator.context.Value().(T), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the float64 value is zero.
//
// For example:
//
//	Is(v.Float64(float64(0)).Zero())
func (validator *ValidatorFloat64[T]) Zero(template ...string) *ValidatorFloat64[T] {
	validator.context.Add(
		func() bool {
			return isFloat64Zero(validator.context.Value().(T))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the float64 value passes a custom function.
// For example:
//
//	quantity := float64(2)
//	Is(v.Float64(quantity).Passing((v float64) bool {
//		return v == getAllowedQuantity()
//	})
func (validator *ValidatorFloat64[T]) Passing(function func(v T) bool, template ...string) *ValidatorFloat64[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the float64 value is present in the float64 slice.
// For example:
//
//	quantity := float64(3)
//	validQuantities := []float64{1,3,5}
//	Is(v.Float64(quantity).InSlice(validQuantities))
func (validator *ValidatorFloat64[T]) InSlice(slice []T, template ...string) *ValidatorFloat64[T] {
	validator.context.AddWithValue(
		func() bool {
			return isFloat64InSlice(validator.context.Value().(T), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}
func isByteEqualTo[T ~byte](v0 T, v1 T) bool {
	return v0 == v1
}
func isByteGreaterThan[T ~byte](v0 T, v1 T) bool {
	return v0 > v1
}
func isByteGreaterOrEqualTo[T ~byte](v0 T, v1 T) bool {
	return v0 >= v1
}
func isByteLessThan[T ~byte](v0 T, v1 T) bool {
	return v0 < v1
}
func isByteLessOrEqualTo[T ~byte](v0 T, v1 T) bool {
	return v0 <= v1
}
func isByteBetween[T ~byte](v T, min T, max T) bool {
	return v >= min && v <= max
}
func isByteZero[T ~byte](v T) bool {
	return v == 0
}
func isByteInSlice[T ~byte](v T, slice []T) bool {
	for _, _v := range slice {
		if v == _v {
			return true
		}
	}
	return false
}

// The byte validator type that keeps its validator context.
type ValidatorByte[T ~byte] struct {
	context *ValidatorContext
}

// Receives the byte value to validate.
//
// The value also can be a custom byte type such as `type Level byte;`
//
// Optionally, the function can receive a name and title, in that order,
// to be displayed in the error messages. A `value_%N`` pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Byte`

func Byte[T ~byte](value T, nameAndTitle ...string) *ValidatorByte[T] {
	return &ValidatorByte[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorByte[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the logical value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	Is(v.Byte(byte(0)).Not().Zero()).Valid()
func (validator *ValidatorByte[T]) Not() *ValidatorByte[T] {
	validator.context.Not()

	return validator
}

// Validate if the byte value is equal to another. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := byte(2)
//	Is(v.Byte(quantity).Equal(byte(2)))
func (validator *ValidatorByte[T]) EqualTo(value T, template ...string) *ValidatorByte[T] {
	validator.context.AddWithValue(
		func() bool {
			return isByteEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the byte value is greater than another. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := byte(3)
//	Is(v.Byte(quantity).GreaterThan(byte(2)))
func (validator *ValidatorByte[T]) GreaterThan(value T, template ...string) *ValidatorByte[T] {
	validator.context.AddWithValue(
		func() bool {
			return isByteGreaterThan(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the byte value is greater than or equal to another. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := byte(3)
//	Is(v.Byte(quantity).GreaterOrEqualTo(byte(3)))
func (validator *ValidatorByte[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorByte[T] {
	validator.context.AddWithValue(
		func() bool {
			return isByteGreaterOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the byte value is less than another. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := byte(2)
//	Is(v.Byte(quantity).LessThan(byte(3)))
func (validator *ValidatorByte[T]) LessThan(value T, template ...string) *ValidatorByte[T] {
	validator.context.AddWithValue(
		func() bool {
			return isByteLessThan(validator.context.Value().(T), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the byte value is less than or equal to another. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := byte(2)
//	Is(v.Byte(quantity).LessOrEqualTo(byte(2)))
func (validator *ValidatorByte[T]) LessOrEqualTo(value T, template ...string) *ValidatorByte[T] {
	validator.context.AddWithValue(
		func() bool {
			return isByteLessOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the byte is within a range (inclusive).
// For example:
//
//	Is(v.Byte(byte(3)).Between(byte(2),byte(6)))
func (validator *ValidatorByte[T]) Between(min T, max T, template ...string) *ValidatorByte[T] {
	validator.context.AddWithParams(
		func() bool {
			return isByteBetween(validator.context.Value().(T), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the byte value is zero.
//
// For example:
//
//	Is(v.Byte(byte(0)).Zero())
func (validator *ValidatorByte[T]) Zero(template ...string) *ValidatorByte[T] {
	validator.context.Add(
		func() bool {
			return isByteZero(validator.context.Value().(T))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the byte value passes a custom function.
// For example:
//
//	quantity := byte(2)
//	Is(v.Byte(quantity).Passing((v byte) bool {
//		return v == getAllowedQuantity()
//	})
func (validator *ValidatorByte[T]) Passing(function func(v T) bool, template ...string) *ValidatorByte[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the byte value is present in the byte slice.
// For example:
//
//	quantity := byte(3)
//	validQuantities := []byte{1,3,5}
//	Is(v.Byte(quantity).InSlice(validQuantities))
func (validator *ValidatorByte[T]) InSlice(slice []T, template ...string) *ValidatorByte[T] {
	validator.context.AddWithValue(
		func() bool {
			return isByteInSlice(validator.context.Value().(T), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}
func isRuneEqualTo[T ~rune](v0 T, v1 T) bool {
	return v0 == v1
}
func isRuneGreaterThan[T ~rune](v0 T, v1 T) bool {
	return v0 > v1
}
func isRuneGreaterOrEqualTo[T ~rune](v0 T, v1 T) bool {
	return v0 >= v1
}
func isRuneLessThan[T ~rune](v0 T, v1 T) bool {
	return v0 < v1
}
func isRuneLessOrEqualTo[T ~rune](v0 T, v1 T) bool {
	return v0 <= v1
}
func isRuneBetween[T ~rune](v T, min T, max T) bool {
	return v >= min && v <= max
}
func isRuneZero[T ~rune](v T) bool {
	return v == 0
}
func isRuneInSlice[T ~rune](v T, slice []T) bool {
	for _, _v := range slice {
		if v == _v {
			return true
		}
	}
	return false
}

// The rune validator type that keeps its validator context.
type ValidatorRune[T ~rune] struct {
	context *ValidatorContext
}

// Receives the rune value to validate.
//
// The value also can be a custom rune type such as `type Level rune;`
//
// Optionally, the function can receive a name and title, in that order,
// to be displayed in the error messages. A `value_%N`` pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Rune`

func Rune[T ~rune](value T, nameAndTitle ...string) *ValidatorRune[T] {
	return &ValidatorRune[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorRune[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the logical value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	Is(v.Rune(rune(0)).Not().Zero()).Valid()
func (validator *ValidatorRune[T]) Not() *ValidatorRune[T] {
	validator.context.Not()

	return validator
}

// Validate if the rune value is equal to another. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := rune(2)
//	Is(v.Rune(quantity).Equal(rune(2)))
func (validator *ValidatorRune[T]) EqualTo(value T, template ...string) *ValidatorRune[T] {
	validator.context.AddWithValue(
		func() bool {
			return isRuneEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the rune value is greater than another. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := rune(3)
//	Is(v.Rune(quantity).GreaterThan(rune(2)))
func (validator *ValidatorRune[T]) GreaterThan(value T, template ...string) *ValidatorRune[T] {
	validator.context.AddWithValue(
		func() bool {
			return isRuneGreaterThan(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the rune value is greater than or equal to another. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := rune(3)
//	Is(v.Rune(quantity).GreaterOrEqualTo(rune(3)))
func (validator *ValidatorRune[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorRune[T] {
	validator.context.AddWithValue(
		func() bool {
			return isRuneGreaterOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the rune value is less than another. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := rune(2)
//	Is(v.Rune(quantity).LessThan(rune(3)))
func (validator *ValidatorRune[T]) LessThan(value T, template ...string) *ValidatorRune[T] {
	validator.context.AddWithValue(
		func() bool {
			return isRuneLessThan(validator.context.Value().(T), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the rune value is less than or equal to another. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := rune(2)
//	Is(v.Rune(quantity).LessOrEqualTo(rune(2)))
func (validator *ValidatorRune[T]) LessOrEqualTo(value T, template ...string) *ValidatorRune[T] {
	validator.context.AddWithValue(
		func() bool {
			return isRuneLessOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the rune is within a range (inclusive).
// For example:
//
//	Is(v.Rune(rune(3)).Between(rune(2),rune(6)))
func (validator *ValidatorRune[T]) Between(min T, max T, template ...string) *ValidatorRune[T] {
	validator.context.AddWithParams(
		func() bool {
			return isRuneBetween(validator.context.Value().(T), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the rune value is zero.
//
// For example:
//
//	Is(v.Rune(rune(0)).Zero())
func (validator *ValidatorRune[T]) Zero(template ...string) *ValidatorRune[T] {
	validator.context.Add(
		func() bool {
			return isRuneZero(validator.context.Value().(T))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the rune value passes a custom function.
// For example:
//
//	quantity := rune(2)
//	Is(v.Rune(quantity).Passing((v rune) bool {
//		return v == getAllowedQuantity()
//	})
func (validator *ValidatorRune[T]) Passing(function func(v T) bool, template ...string) *ValidatorRune[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the rune value is present in the rune slice.
// For example:
//
//	quantity := rune(3)
//	validQuantities := []rune{1,3,5}
//	Is(v.Rune(quantity).InSlice(validQuantities))
func (validator *ValidatorRune[T]) InSlice(slice []T, template ...string) *ValidatorRune[T] {
	validator.context.AddWithValue(
		func() bool {
			return isRuneInSlice(validator.context.Value().(T), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}

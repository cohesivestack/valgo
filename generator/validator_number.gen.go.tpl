// Code generated by Valgo; DO NOT EDIT.

package valgo

{{ range . }}

func is{{ .Name }}EqualTo[T ~{{ .Type }}](v0 T, v1 T) bool {
	return v0 == v1
}

func is{{ .Name }}GreaterThan[T ~{{ .Type }}](v0 T, v1 T) bool {
	return v0 > v1
}
func is{{ .Name }}GreaterOrEqualTo[T ~{{ .Type }}](v0 T, v1 T) bool {
	return v0 >= v1
}
func is{{ .Name }}LessThan[T ~{{ .Type }}](v0 T, v1 T) bool {
	return v0 < v1
}
func is{{ .Name }}LessOrEqualTo[T ~{{ .Type }}](v0 T, v1 T) bool {
	return v0 <= v1
}
func is{{ .Name }}Between[T ~{{ .Type }}](v T, min T, max T) bool {
	return v >= min && v <= max
}
func is{{ .Name }}Zero[T ~{{ .Type }}](v T) bool {
	return v == 0
}
func is{{ .Name }}InSlice[T ~{{ .Type }}](v T, slice []T) bool {
	for _, _v := range slice {
		if v == _v {
			return true
		}
	}
	return false
}

type Validator{{ .Name }}[T ~{{ .Type }}] struct {
	context *ValidatorContext
}

// Receives a number value to validate.
//
// The value also can be any golang number type (int64, int32, float32, uint,
// etc.) or a custom number type such as `type Level int32;`
//
// Optionally, the function can receive a name and title, in that order,
// to be used in the error messages. A `value_%N`` pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone {{ .Name }}`

func {{ .Name }}[T ~{{ .Type }}](value T, nameAndTitle ...string) *Validator{{ .Name }}[T] {
	return &Validator{{ .Name }}[T]{context: NewContext(value, nameAndTitle...)}
}

// This function returns the context for the Valgo Validator session's
// validator. The function should not be called unless you are creating a custom
// validator by extending this validator.
func (validator *Validator{{ .Name }}[T]) Context() *ValidatorContext {
	return validator.context
}

// Reverse the logical value associated to the next validation function.
// For example:
//
//	// It will return false because Not() inverts to Zero()
//	Is(v.{{ .Name }}(0).Not().Zero()).Valid()
func (validator *Validator{{ .Name }}[T]) EqualTo(value T, template ...string) *Validator{{ .Name }}[T] {
	validator.context.AddWithValue(
		func() bool {
			return is{{ .Name }}EqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

func (validator *Validator{{ .Name }}[T]) GreaterThan(value T, template ...string) *Validator{{ .Name }}[T] {
	validator.context.AddWithValue(
		func() bool {
			return is{{ .Name }}GreaterThan(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

func (validator *Validator{{ .Name }}[T]) GreaterOrEqualTo(value T, template ...string) *Validator{{ .Name }}[T] {
	validator.context.AddWithValue(
		func() bool {
			return is{{ .Name }}GreaterOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

func (validator *Validator{{ .Name }}[T]) LessThan(value T, template ...string) *Validator{{ .Name }}[T] {
	validator.context.AddWithValue(
		func() bool {
			return is{{ .Name }}LessThan(validator.context.Value().(T), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

func (validator *Validator{{ .Name }}[T]) LessOrEqualTo(value T, template ...string) *Validator{{ .Name }}[T] {
	validator.context.AddWithValue(
		func() bool {
			return is{{ .Name }}LessOrEqualTo(validator.context.Value().(T), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of a number is in a range (inclusive).
// For example:
//
//	Is(v.{{ .Name }}(3).Between(2,6))
func (validator *Validator{{ .Name }}[T]) Between(min T, max T, template ...string) *Validator{{ .Name }}[T] {
	validator.context.AddWithParams(
		func() bool {
			return is{{ .Name }}Between(validator.context.Value().(T), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

func (validator *Validator{{ .Name }}[T]) Zero(template ...string) *Validator{{ .Name }}[T] {
	validator.context.Add(
		func() bool {
			return is{{ .Name }}Zero(validator.context.Value().(T))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *Validator{{ .Name }}[T]) Passing(function func(v T) bool, template ...string) *Validator{{ .Name }}[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(T))
		},
		ErrorKeyPassing, template...)

	return validator
}

func (validator *Validator{{ .Name }}[T]) InSlice(slice []T, template ...string) *Validator{{ .Name }}[T] {
	validator.context.AddWithValue(
		func() bool {
			return is{{ .Name }}InSlice(validator.context.Value().(T), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}

func (validator *Validator{{ .Name }}[T]) Not() *Validator{{ .Name }}[T] {
	validator.context.Not()

	return validator
}

{{ end }}
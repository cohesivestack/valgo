// Code generated by Valgo; DO NOT EDIT.
package valgo

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

{{ range . -}}
func TestValidator{{ .Name }}Not(t *testing.T) {
	v := Is({{ .Name }}({{ .Type }}(1)).Not().EqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidator{{ .Name }}EqualToValid(t *testing.T) {
	var v *Validation

	v = Is({{ .Name }}({{ .Type }}(2)).EqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type My{{ .Name }} {{ .Type }}
	var my{{ .Name }}1 My{{ .Name }} = 2
	var my{{ .Name }}2 My{{ .Name }} = 2

	v = Is({{ .Name }}(My{{ .Name }}(my{{ .Name }}1)).EqualTo(my{{ .Name }}2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidator{{ .Name }}EqualToInvalid(t *testing.T) {
	var v *Validation

	v = Is({{ .Name }}({{ .Type }}(1)).EqualTo(2))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type My{{ .Name }} {{ .Type }}
	var my{{ .Name }}1 My{{ .Name }} = 1
	var my{{ .Name }}2 My{{ .Name }} = 2

	v = Is({{ .Name }}(My{{ .Name }}(my{{ .Name }}1)).EqualTo(my{{ .Name }}2))
	assert.False(t, v.Valid())
	assert.NotEmpty(t, v.Errors())
	assert.Equal(t,
		"Value 0 must be equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidator{{ .Name }}GreaterThanValid(t *testing.T) {
	var v *Validation

	v = Is({{ .Name }}({{ .Type }}(3)).GreaterThan(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type My{{ .Name }} {{ .Type }}
	var my{{ .Name }}1 My{{ .Name }} = 3
	var my{{ .Name }}2 My{{ .Name }} = 2

	v = Is({{ .Name }}(My{{ .Name }}(my{{ .Name }}1)).GreaterThan(my{{ .Name }}2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidator{{ .Name }}GreaterThanInvalid(t *testing.T) {
	var v *Validation

	v = Is({{ .Name }}({{ .Type }}(2)).GreaterThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	v = Is({{ .Name }}({{ .Type }}(2)).GreaterThan(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type My{{ .Name }} {{ .Type }}
	var my{{ .Name }}1 My{{ .Name }} = 2
	var my{{ .Name }}2 My{{ .Name }} = 2

	v = Is({{ .Name }}(My{{ .Name }}(my{{ .Name }}1)).GreaterThan(my{{ .Name }}2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidator{{ .Name }}GreaterOrEqualToValid(t *testing.T) {
	var v *Validation

	v = Is({{ .Name }}({{ .Type }}(2)).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	v = Is({{ .Name }}({{ .Type }}(3)).GreaterOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type My{{ .Name }} {{ .Type }}
	var my{{ .Name }}1 My{{ .Name }} = 2
	var my{{ .Name }}2 My{{ .Name }} = 2

	v = Is({{ .Name }}(My{{ .Name }}(my{{ .Name }}1)).GreaterOrEqualTo(my{{ .Name }}2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidator{{ .Name }}GreaterOrEqualToInvalid(t *testing.T) {
	var v *Validation

	v = Is({{ .Name }}({{ .Type }}(2)).GreaterOrEqualTo(3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type My{{ .Name }} {{ .Type }}
	var my{{ .Name }}1 My{{ .Name }} = 2
	var my{{ .Name }}2 My{{ .Name }} = 3

	v = Is({{ .Name }}(My{{ .Name }}(my{{ .Name }}1)).GreaterOrEqualTo(my{{ .Name }}2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be greater than or equal to \"3\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidator{{ .Name }}LessThanValid(t *testing.T) {
	var v *Validation

	v = Is({{ .Name }}({{ .Type }}(2)).LessThan(3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type My{{ .Name }} {{ .Type }}
	var my{{ .Name }}1 My{{ .Name }} = 2
	var my{{ .Name }}2 My{{ .Name }} = 3

	v = Is({{ .Name }}(My{{ .Name }}(my{{ .Name }}1)).LessThan(my{{ .Name }}2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidator{{ .Name }}LessThanInvalid(t *testing.T) {
	var v *Validation

	v = Is({{ .Name }}({{ .Type }}(2)).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	v = Is({{ .Name }}({{ .Type }}(3)).LessThan(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type My{{ .Name }} {{ .Type }}
	var my{{ .Name }}1 My{{ .Name }} = 2
	var my{{ .Name }}2 My{{ .Name }} = 2

	v = Is({{ .Name }}(My{{ .Name }}(my{{ .Name }}1)).LessThan(my{{ .Name }}2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidator{{ .Name }}LessOrEqualToValid(t *testing.T) {
	var v *Validation

	v = Is({{ .Name }}({{ .Type }}(2)).LessOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	v = Is({{ .Name }}({{ .Type }}(1)).LessOrEqualTo(2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type My{{ .Name }} {{ .Type }}
	var my{{ .Name }}1 My{{ .Name }} = 2
	var my{{ .Name }}2 My{{ .Name }} = 2

	v = Is({{ .Name }}(My{{ .Name }}(my{{ .Name }}1)).LessOrEqualTo(my{{ .Name }}2))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidator{{ .Name }}LessOrEqualToInvalid(t *testing.T) {
	var v *Validation

	v = Is({{ .Name }}({{ .Type }}(3)).LessOrEqualTo(2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type My{{ .Name }} {{ .Type }}
	var my{{ .Name }}1 My{{ .Name }} = 3
	var my{{ .Name }}2 My{{ .Name }} = 2

	v = Is({{ .Name }}(My{{ .Name }}(my{{ .Name }}1)).LessOrEqualTo(my{{ .Name }}2))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be less than or equal to \"2\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidator{{ .Name }}BetweenValid(t *testing.T) {
	var v *Validation

	v = Is({{ .Name }}({{ .Type }}(2)).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	v = Is({{ .Name }}({{ .Type }}(4)).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	v = Is({{ .Name }}({{ .Type }}(6)).Between(2, 6))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type My{{ .Name }} {{ .Type }}
	var my{{ .Name }}1 My{{ .Name }} = 2
	var my{{ .Name }}2 My{{ .Name }} = 2
	var my{{ .Name }}3 My{{ .Name }} = 6

	v = Is({{ .Name }}(My{{ .Name }}(my{{ .Name }}1)).Between(my{{ .Name }}2, my{{ .Name }}3))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidator{{ .Name }}BetweenInvalid(t *testing.T) {
	var v *Validation

	v = Is({{ .Name }}({{ .Type }}(2)).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	v = Is({{ .Name }}({{ .Type }}(7)).Between(3, 6))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type My{{ .Name }} {{ .Type }}
	var my{{ .Name }}1 My{{ .Name }} = 2
	var my{{ .Name }}2 My{{ .Name }} = 3
	var my{{ .Name }}3 My{{ .Name }} = 6

	v = Is({{ .Name }}(My{{ .Name }}(my{{ .Name }}1)).Between(my{{ .Name }}2, my{{ .Name }}3))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be between \"3\" and \"6\"",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidator{{ .Name }}ZeroValid(t *testing.T) {
	var v *Validation

	v = Is({{ .Name }}({{ .Type }}(0)).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type My{{ .Name }} {{ .Type }}
	var my{{ .Name }}1 My{{ .Name }} = 0

	v = Is({{ .Name }}({{ .Type }}(my{{ .Name }}1)).Zero())
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}
func TestValidator{{ .Name }}ZeroInvalid(t *testing.T) {
	var v *Validation

	v = Is({{ .Name }}({{ .Type }}(1)).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type My{{ .Name }} {{ .Type }}
	var my{{ .Name }}1 My{{ .Name }} = 1

	v = Is({{ .Name }}({{ .Type }}(my{{ .Name }}1)).Zero())
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 must be zero",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidator{{ .Name }}PassingValid(t *testing.T) {
	var v *Validation

	v = Is({{ .Name }}({{ .Type }}(1)).Passing(func(val {{ .Type }}) bool {
		return val == 1
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type My{{ .Name }} {{ .Type }}
	var my{{ .Name }}1 My{{ .Name }} = 1

	v = Is({{ .Name }}(My{{ .Name }}(my{{ .Name }}1)).Passing(func(val My{{ .Name }}) bool {
		return val == 1
	}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidator{{ .Name }}PassingInvalid(t *testing.T) {
	var v *Validation

	v = Is({{ .Name }}({{ .Type }}(1)).Passing(func(val {{ .Type }}) bool {
		return val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type My{{ .Name }} {{ .Type }}
	var my{{ .Name }}1 My{{ .Name }} = 1

	v = Is({{ .Name }}(My{{ .Name }}(my{{ .Name }}1)).Passing(func(val My{{ .Name }}) bool {
		return val == 2
	}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidator{{ .Name }}InSliceValid(t *testing.T) {
	var v *Validation

	v = Is({{ .Name }}({{ .Type }}(2)).InSlice([]{{ .Type }}{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())

	// Custom Type
	type My{{ .Name }} {{ .Type }}
	var my{{ .Name }}1 My{{ .Name }} = 2

	v = Is({{ .Name }}(My{{ .Name }}(my{{ .Name }}1)).InSlice([]My{{ .Name }}{1, 2, 3}))
	assert.True(t, v.Valid())
	assert.Empty(t, v.Errors())
}

func TestValidator{{ .Name }}InSliceInvalid(t *testing.T) {
	var v *Validation

	v = Is({{ .Name }}({{ .Type }}(4)).InSlice([]{{ .Type }}{1, 2, 3}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])

	// Custom Type
	type My{{ .Name }} {{ .Type }}
	var my{{ .Name }}1 My{{ .Name }} = 4

	v = Is({{ .Name }}(My{{ .Name }}(my{{ .Name }}1)).InSlice([]My{{ .Name }}{1, 2, 3}))
	assert.False(t, v.Valid())
	assert.Equal(t,
		"Value 0 is not valid",
		v.Errors()["value_0"].Messages()[0])
}

func TestValidator{{ .Name }}OrOperatorWithIs(t *testing.T) {
	var v *Validation

	var _true = true
	var _false = false

	// Testing Or operation with two valid conditions
	v = Is({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(1)).Or().EqualTo({{ .Type }}(1)))
	assert.True(t, v.Valid())
	assert.Equal(t, _true || true, v.Valid())
	assert.Empty(t, v.Errors())

	// Testing Or operation with left invalid and right valid conditions
	v = Is({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(0)).Or().EqualTo({{ .Type }}(1)))
	assert.True(t, v.Valid())
	assert.Equal(t, false || true, v.Valid())
	assert.Empty(t, v.Errors())

	// Testing Or operation with left valid and right invalid conditions
	v = Is({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(1)).Or().EqualTo({{ .Type }}(0)))
	assert.True(t, v.Valid())
	assert.Equal(t, true || false, v.Valid())
	assert.Empty(t, v.Errors())

	// Testing Or operation with two invalid conditions
	v = Is({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(0)).Or().EqualTo({{ .Type }}(0)))
	assert.False(t, v.Valid())
	assert.Equal(t, _false || false, v.Valid())
	assert.NotEmpty(t, v.Errors())

	// Testing And operation (default when no Or() function is used) with left valid and right invalid conditions
	v = Is({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(1)).EqualTo({{ .Type }}(0)))
	assert.False(t, v.Valid())
	assert.Equal(t, true && false, v.Valid())
	assert.NotEmpty(t, v.Errors())

	// Testing combination of Not and Or operators with left valid and right invalid conditions
	v = Is({{ .Name }}({{ .Type }}(1)).Not().EqualTo({{ .Type }}(0)).Or().EqualTo({{ .Type }}(0)))
	assert.True(t, v.Valid())
	assert.Equal(t, !false || false, v.Valid())
	assert.Empty(t, v.Errors())

	// Testing combination of Not and Or operators with left invalid and right valid conditions
	v = Is({{ .Name }}({{ .Type }}(1)).Not().EqualTo({{ .Type }}(1)).Or().EqualTo({{ .Type }}(1)))
	assert.True(t, v.Valid())
	assert.Equal(t, !true || true, v.Valid())
	assert.Empty(t, v.Errors())

	// Testing multiple Or operations in sequence with the first condition being valid
	v = Is({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(1)).Or().EqualTo({{ .Type }}(0)).Or().EqualTo({{ .Type }}(0)))
	assert.True(t, v.Valid())
	assert.Equal(t, true || _false || false, v.Valid())
	assert.Empty(t, v.Errors())

	// Testing multiple Or operations in sequence with the last condition being valid
	v = Is({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(0)).Or().EqualTo({{ .Type }}(0)).Or().EqualTo({{ .Type }}(1)))
	assert.True(t, v.Valid())
	assert.Equal(t, _false || false || true, v.Valid())
	assert.Empty(t, v.Errors())

	// Testing invalid Or operation then valid And operation
	v = Is({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(0)).Or().EqualTo({{ .Type }}(1)).EqualTo({{ .Type }}(1)))
	assert.True(t, v.Valid())
	assert.Equal(t, false || _true && true, v.Valid())
	assert.Empty(t, v.Errors())

	// Testing valid Or operation then invalid And operation
	v = Is({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(0)).Or().EqualTo({{ .Type }}(1)).EqualTo({{ .Type }}(0)))
	assert.False(t, v.Valid())
	assert.Equal(t, false || true && false, v.Valid())
	assert.NotEmpty(t, v.Errors())

	// Testing valid And operation then invalid Or operation
	v = Is({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(1)).EqualTo({{ .Type }}(1)).Or().EqualTo({{ .Type }}(0)))
	assert.True(t, v.Valid())
	assert.Equal(t, _true && true || false, v.Valid())
	assert.Empty(t, v.Errors())

	// Testing invalid And operation then valid Or operation
	v = Is({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(1)).EqualTo({{ .Type }}(0)).Or().EqualTo({{ .Type }}(1)))
	assert.True(t, v.Valid())
	assert.Equal(t, true && false || true, v.Valid())
	assert.Empty(t, v.Errors())

}

func TestValidator{{ .Name }}OrOperatorWithCheck(t *testing.T) {
	var v *Validation

	// Check are Non-Short-circuited operations

	var _true = true
	var _false = false

	// Testing Or operation with two valid conditions
	v = Check({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(1)).Or().EqualTo({{ .Type }}(1)))
	assert.True(t, v.Valid())
	assert.Equal(t, _true || true, v.Valid())
	assert.Empty(t, v.Errors())

	// Testing Or operation with left invalid and right valid conditions
	v = Check({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(0)).Or().EqualTo({{ .Type }}(1)))
	assert.True(t, v.Valid())
	assert.Equal(t, false || true, v.Valid())
	assert.Empty(t, v.Errors())

	// Testing Or operation with left valid and right invalid conditions
	v = Check({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(1)).Or().EqualTo({{ .Type }}(0)))
	assert.True(t, v.Valid())
	assert.Equal(t, true || false, v.Valid())
	assert.Empty(t, v.Errors())

	// Testing Or operation with two invalid conditions
	v = Check({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(0)).Or().EqualTo({{ .Type }}(0)))
	assert.False(t, v.Valid())
	assert.Equal(t, _false || false, v.Valid())
	assert.NotEmpty(t, v.Errors())

	// Testing And operation (default when no Or() function is used) with left valid and right invalid conditions
	v = Check({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(1)).EqualTo({{ .Type }}(0)))
	assert.False(t, v.Valid())
	assert.Equal(t, true && false, v.Valid())
	assert.NotEmpty(t, v.Errors())

	// Testing combination of Not and Or operators with left valid and right invalid conditions
	v = Check({{ .Name }}({{ .Type }}(1)).Not().EqualTo({{ .Type }}(0)).Or().EqualTo({{ .Type }}(0)))
	assert.True(t, v.Valid())
	assert.Equal(t, !false || false, v.Valid())
	assert.Empty(t, v.Errors())

	// Testing combination of Not and Or operators with left invalid and right valid conditions
	v = Check({{ .Name }}({{ .Type }}(1)).Not().EqualTo({{ .Type }}(1)).Or().EqualTo({{ .Type }}(1)))
	assert.True(t, v.Valid())
	assert.Equal(t, !true || true, v.Valid())
	assert.Empty(t, v.Errors())

	// Testing multiple Or operations in sequence with the first condition being valid
	v = Check({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(1)).Or().EqualTo({{ .Type }}(0)).Or().EqualTo({{ .Type }}(0)))
	assert.True(t, v.Valid())
	assert.Equal(t, true || _false || false, v.Valid())
	assert.Empty(t, v.Errors())

	// Testing multiple Or operations in sequence with the last condition being valid
	v = Check({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(0)).Or().EqualTo({{ .Type }}(0)).Or().EqualTo({{ .Type }}(1)))
	assert.True(t, v.Valid())
	assert.Equal(t, _false || false || true, v.Valid())
	assert.Empty(t, v.Errors())

	// Testing invalid Or operation then valid And operation
	v = Check({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(0)).Or().EqualTo({{ .Type }}(1)).EqualTo({{ .Type }}(1)))
	assert.True(t, v.Valid())
	assert.Equal(t, false || _true && true, v.Valid())
	assert.Empty(t, v.Errors())

	// Testing valid Or operation then invalid And operation
	v = Check({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(0)).Or().EqualTo({{ .Type }}(1)).EqualTo({{ .Type }}(0)))
	assert.False(t, v.Valid())
	assert.Equal(t, false || true && false, v.Valid())
	assert.NotEmpty(t, v.Errors())

	// Testing valid And operation then invalid Or operation
	v = Check({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(1)).EqualTo({{ .Type }}(1)).Or().EqualTo({{ .Type }}(0)))
	assert.True(t, v.Valid())
	assert.Equal(t, _true && true || false, v.Valid())
	assert.Empty(t, v.Errors())

	// Testing invalid And operation then valid Or operation
	v = Check({{ .Name }}({{ .Type }}(1)).EqualTo({{ .Type }}(1)).EqualTo({{ .Type }}(0)).Or().EqualTo({{ .Type }}(1)))
	assert.True(t, v.Valid())
	assert.Equal(t, true && false || true, v.Valid())
	assert.Empty(t, v.Errors())
}

{{ end }}
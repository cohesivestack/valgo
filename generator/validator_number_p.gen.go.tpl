// Code generated by Valgo; DO NOT EDIT.

package valgo

{{ range . }}

type Validator{{ .Name }}P[T ~{{ .Type }}] struct {
	context *ValidatorContext
}

func {{ .Name }}P[T ~{{ .Type }}](value *T, nameAndTitle ...string) *Validator{{ .Name }}P[T] {
	return &Validator{{ .Name }}P[T]{context: NewContext(value, nameAndTitle...)}
}

func (validator *Validator{{ .Name }}P[T]) Context() *ValidatorContext {
	return validator.context
}

func (validator *Validator{{ .Name }}P[T]) EqualTo(value T, template ...string) *Validator{{ .Name }}P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && is{{ .Name }}EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

func (validator *Validator{{ .Name }}P[T]) GreaterThan(value T, template ...string) *Validator{{ .Name }}P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && is{{ .Name }}GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

func (validator *Validator{{ .Name }}P[T]) GreaterOrEqualTo(value T, template ...string) *Validator{{ .Name }}P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && is{{ .Name }}GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

func (validator *Validator{{ .Name }}P[T]) LessThan(value T, template ...string) *Validator{{ .Name }}P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && is{{ .Name }}LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

func (validator *Validator{{ .Name }}P[T]) LessOrEqualTo(value T, template ...string) *Validator{{ .Name }}P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && is{{ .Name }}LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of a number is in a range (inclusive).
// For example:
//
//	Is(v.{{ .Name }}(3).Between(2,6))
func (validator *Validator{{ .Name }}P[T]) Between(min T, max T, template ...string) *Validator{{ .Name }}P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && is{{ .Name }}Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

func (validator *Validator{{ .Name }}P[T]) Zero(template ...string) *Validator{{ .Name }}P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && is{{ .Name }}Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *Validator{{ .Name }}P[T]) ZeroOrNil(template ...string) *Validator{{ .Name }}P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || is{{ .Name }}Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *Validator{{ .Name }}P[T]) Nil(template ...string) *Validator{{ .Name }}P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

func (validator *Validator{{ .Name }}P[T]) Passing(function func(v *T) bool, template ...string) *Validator{{ .Name }}P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

func (validator *Validator{{ .Name }}P[T]) InSlice(slice []T, template ...string) *Validator{{ .Name }}P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && is{{ .Name }}InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}

func (validator *Validator{{ .Name }}P[T]) Not() *Validator{{ .Name }}P[T] {
	validator.context.Not()

	return validator
}

{{ end }}
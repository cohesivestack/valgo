// Code generated by Valgo; DO NOT EDIT.

package valgo



type ValidatorUint8P[T ~uint8] struct {
	context *ValidatorContext
}

func Uint8P[T ~uint8](value *T, nameAndTitle ...string) *ValidatorUint8P[T] {
	return &ValidatorUint8P[T]{context: NewContext(value, nameAndTitle...)}
}

func (validator *ValidatorUint8P[T]) Context() *ValidatorContext {
	return validator.context
}

func (validator *ValidatorUint8P[T]) EqualTo(value T, template ...string) *ValidatorUint8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint8EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

func (validator *ValidatorUint8P[T]) GreaterThan(value T, template ...string) *ValidatorUint8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint8GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

func (validator *ValidatorUint8P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorUint8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint8GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

func (validator *ValidatorUint8P[T]) LessThan(value T, template ...string) *ValidatorUint8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint8LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

func (validator *ValidatorUint8P[T]) LessOrEqualTo(value T, template ...string) *ValidatorUint8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint8LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of a number is in a range (inclusive).
// For example:
//
//	Is(v.Uint8(3).Between(2,6))
func (validator *ValidatorUint8P[T]) Between(min T, max T, template ...string) *ValidatorUint8P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint8Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

func (validator *ValidatorUint8P[T]) Zero(template ...string) *ValidatorUint8P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint8Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorUint8P[T]) ZeroOrNil(template ...string) *ValidatorUint8P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isUint8Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorUint8P[T]) Nil(template ...string) *ValidatorUint8P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

func (validator *ValidatorUint8P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorUint8P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

func (validator *ValidatorUint8P[T]) InSlice(slice []T, template ...string) *ValidatorUint8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint8InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}

func (validator *ValidatorUint8P[T]) Not() *ValidatorUint8P[T] {
	validator.context.Not()

	return validator
}



type ValidatorUint16P[T ~uint16] struct {
	context *ValidatorContext
}

func Uint16P[T ~uint16](value *T, nameAndTitle ...string) *ValidatorUint16P[T] {
	return &ValidatorUint16P[T]{context: NewContext(value, nameAndTitle...)}
}

func (validator *ValidatorUint16P[T]) Context() *ValidatorContext {
	return validator.context
}

func (validator *ValidatorUint16P[T]) EqualTo(value T, template ...string) *ValidatorUint16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint16EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

func (validator *ValidatorUint16P[T]) GreaterThan(value T, template ...string) *ValidatorUint16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint16GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

func (validator *ValidatorUint16P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorUint16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint16GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

func (validator *ValidatorUint16P[T]) LessThan(value T, template ...string) *ValidatorUint16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint16LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

func (validator *ValidatorUint16P[T]) LessOrEqualTo(value T, template ...string) *ValidatorUint16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint16LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of a number is in a range (inclusive).
// For example:
//
//	Is(v.Uint16(3).Between(2,6))
func (validator *ValidatorUint16P[T]) Between(min T, max T, template ...string) *ValidatorUint16P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint16Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

func (validator *ValidatorUint16P[T]) Zero(template ...string) *ValidatorUint16P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint16Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorUint16P[T]) ZeroOrNil(template ...string) *ValidatorUint16P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isUint16Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorUint16P[T]) Nil(template ...string) *ValidatorUint16P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

func (validator *ValidatorUint16P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorUint16P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

func (validator *ValidatorUint16P[T]) InSlice(slice []T, template ...string) *ValidatorUint16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint16InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}

func (validator *ValidatorUint16P[T]) Not() *ValidatorUint16P[T] {
	validator.context.Not()

	return validator
}



type ValidatorUint32P[T ~uint32] struct {
	context *ValidatorContext
}

func Uint32P[T ~uint32](value *T, nameAndTitle ...string) *ValidatorUint32P[T] {
	return &ValidatorUint32P[T]{context: NewContext(value, nameAndTitle...)}
}

func (validator *ValidatorUint32P[T]) Context() *ValidatorContext {
	return validator.context
}

func (validator *ValidatorUint32P[T]) EqualTo(value T, template ...string) *ValidatorUint32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint32EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

func (validator *ValidatorUint32P[T]) GreaterThan(value T, template ...string) *ValidatorUint32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint32GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

func (validator *ValidatorUint32P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorUint32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint32GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

func (validator *ValidatorUint32P[T]) LessThan(value T, template ...string) *ValidatorUint32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint32LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

func (validator *ValidatorUint32P[T]) LessOrEqualTo(value T, template ...string) *ValidatorUint32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint32LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of a number is in a range (inclusive).
// For example:
//
//	Is(v.Uint32(3).Between(2,6))
func (validator *ValidatorUint32P[T]) Between(min T, max T, template ...string) *ValidatorUint32P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint32Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

func (validator *ValidatorUint32P[T]) Zero(template ...string) *ValidatorUint32P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint32Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorUint32P[T]) ZeroOrNil(template ...string) *ValidatorUint32P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isUint32Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorUint32P[T]) Nil(template ...string) *ValidatorUint32P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

func (validator *ValidatorUint32P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorUint32P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

func (validator *ValidatorUint32P[T]) InSlice(slice []T, template ...string) *ValidatorUint32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint32InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}

func (validator *ValidatorUint32P[T]) Not() *ValidatorUint32P[T] {
	validator.context.Not()

	return validator
}



type ValidatorUint64P[T ~uint64] struct {
	context *ValidatorContext
}

func Uint64P[T ~uint64](value *T, nameAndTitle ...string) *ValidatorUint64P[T] {
	return &ValidatorUint64P[T]{context: NewContext(value, nameAndTitle...)}
}

func (validator *ValidatorUint64P[T]) Context() *ValidatorContext {
	return validator.context
}

func (validator *ValidatorUint64P[T]) EqualTo(value T, template ...string) *ValidatorUint64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint64EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

func (validator *ValidatorUint64P[T]) GreaterThan(value T, template ...string) *ValidatorUint64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint64GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

func (validator *ValidatorUint64P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorUint64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint64GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

func (validator *ValidatorUint64P[T]) LessThan(value T, template ...string) *ValidatorUint64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint64LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

func (validator *ValidatorUint64P[T]) LessOrEqualTo(value T, template ...string) *ValidatorUint64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint64LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of a number is in a range (inclusive).
// For example:
//
//	Is(v.Uint64(3).Between(2,6))
func (validator *ValidatorUint64P[T]) Between(min T, max T, template ...string) *ValidatorUint64P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint64Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

func (validator *ValidatorUint64P[T]) Zero(template ...string) *ValidatorUint64P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint64Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorUint64P[T]) ZeroOrNil(template ...string) *ValidatorUint64P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isUint64Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorUint64P[T]) Nil(template ...string) *ValidatorUint64P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

func (validator *ValidatorUint64P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorUint64P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

func (validator *ValidatorUint64P[T]) InSlice(slice []T, template ...string) *ValidatorUint64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint64InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}

func (validator *ValidatorUint64P[T]) Not() *ValidatorUint64P[T] {
	validator.context.Not()

	return validator
}



type ValidatorIntP[T ~int] struct {
	context *ValidatorContext
}

func IntP[T ~int](value *T, nameAndTitle ...string) *ValidatorIntP[T] {
	return &ValidatorIntP[T]{context: NewContext(value, nameAndTitle...)}
}

func (validator *ValidatorIntP[T]) Context() *ValidatorContext {
	return validator.context
}

func (validator *ValidatorIntP[T]) EqualTo(value T, template ...string) *ValidatorIntP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isIntEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

func (validator *ValidatorIntP[T]) GreaterThan(value T, template ...string) *ValidatorIntP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isIntGreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

func (validator *ValidatorIntP[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorIntP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isIntGreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

func (validator *ValidatorIntP[T]) LessThan(value T, template ...string) *ValidatorIntP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isIntLessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

func (validator *ValidatorIntP[T]) LessOrEqualTo(value T, template ...string) *ValidatorIntP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isIntLessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of a number is in a range (inclusive).
// For example:
//
//	Is(v.Int(3).Between(2,6))
func (validator *ValidatorIntP[T]) Between(min T, max T, template ...string) *ValidatorIntP[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isIntBetween(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

func (validator *ValidatorIntP[T]) Zero(template ...string) *ValidatorIntP[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isIntZero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorIntP[T]) ZeroOrNil(template ...string) *ValidatorIntP[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isIntZero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorIntP[T]) Nil(template ...string) *ValidatorIntP[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

func (validator *ValidatorIntP[T]) Passing(function func(v *T) bool, template ...string) *ValidatorIntP[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

func (validator *ValidatorIntP[T]) InSlice(slice []T, template ...string) *ValidatorIntP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isIntInSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}

func (validator *ValidatorIntP[T]) Not() *ValidatorIntP[T] {
	validator.context.Not()

	return validator
}



type ValidatorInt8P[T ~int8] struct {
	context *ValidatorContext
}

func Int8P[T ~int8](value *T, nameAndTitle ...string) *ValidatorInt8P[T] {
	return &ValidatorInt8P[T]{context: NewContext(value, nameAndTitle...)}
}

func (validator *ValidatorInt8P[T]) Context() *ValidatorContext {
	return validator.context
}

func (validator *ValidatorInt8P[T]) EqualTo(value T, template ...string) *ValidatorInt8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt8EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

func (validator *ValidatorInt8P[T]) GreaterThan(value T, template ...string) *ValidatorInt8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt8GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

func (validator *ValidatorInt8P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorInt8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt8GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

func (validator *ValidatorInt8P[T]) LessThan(value T, template ...string) *ValidatorInt8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt8LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

func (validator *ValidatorInt8P[T]) LessOrEqualTo(value T, template ...string) *ValidatorInt8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt8LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of a number is in a range (inclusive).
// For example:
//
//	Is(v.Int8(3).Between(2,6))
func (validator *ValidatorInt8P[T]) Between(min T, max T, template ...string) *ValidatorInt8P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt8Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

func (validator *ValidatorInt8P[T]) Zero(template ...string) *ValidatorInt8P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt8Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorInt8P[T]) ZeroOrNil(template ...string) *ValidatorInt8P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isInt8Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorInt8P[T]) Nil(template ...string) *ValidatorInt8P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

func (validator *ValidatorInt8P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorInt8P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

func (validator *ValidatorInt8P[T]) InSlice(slice []T, template ...string) *ValidatorInt8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt8InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}

func (validator *ValidatorInt8P[T]) Not() *ValidatorInt8P[T] {
	validator.context.Not()

	return validator
}



type ValidatorInt16P[T ~int16] struct {
	context *ValidatorContext
}

func Int16P[T ~int16](value *T, nameAndTitle ...string) *ValidatorInt16P[T] {
	return &ValidatorInt16P[T]{context: NewContext(value, nameAndTitle...)}
}

func (validator *ValidatorInt16P[T]) Context() *ValidatorContext {
	return validator.context
}

func (validator *ValidatorInt16P[T]) EqualTo(value T, template ...string) *ValidatorInt16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt16EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

func (validator *ValidatorInt16P[T]) GreaterThan(value T, template ...string) *ValidatorInt16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt16GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

func (validator *ValidatorInt16P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorInt16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt16GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

func (validator *ValidatorInt16P[T]) LessThan(value T, template ...string) *ValidatorInt16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt16LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

func (validator *ValidatorInt16P[T]) LessOrEqualTo(value T, template ...string) *ValidatorInt16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt16LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of a number is in a range (inclusive).
// For example:
//
//	Is(v.Int16(3).Between(2,6))
func (validator *ValidatorInt16P[T]) Between(min T, max T, template ...string) *ValidatorInt16P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt16Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

func (validator *ValidatorInt16P[T]) Zero(template ...string) *ValidatorInt16P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt16Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorInt16P[T]) ZeroOrNil(template ...string) *ValidatorInt16P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isInt16Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorInt16P[T]) Nil(template ...string) *ValidatorInt16P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

func (validator *ValidatorInt16P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorInt16P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

func (validator *ValidatorInt16P[T]) InSlice(slice []T, template ...string) *ValidatorInt16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt16InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}

func (validator *ValidatorInt16P[T]) Not() *ValidatorInt16P[T] {
	validator.context.Not()

	return validator
}



type ValidatorInt32P[T ~int32] struct {
	context *ValidatorContext
}

func Int32P[T ~int32](value *T, nameAndTitle ...string) *ValidatorInt32P[T] {
	return &ValidatorInt32P[T]{context: NewContext(value, nameAndTitle...)}
}

func (validator *ValidatorInt32P[T]) Context() *ValidatorContext {
	return validator.context
}

func (validator *ValidatorInt32P[T]) EqualTo(value T, template ...string) *ValidatorInt32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt32EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

func (validator *ValidatorInt32P[T]) GreaterThan(value T, template ...string) *ValidatorInt32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt32GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

func (validator *ValidatorInt32P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorInt32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt32GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

func (validator *ValidatorInt32P[T]) LessThan(value T, template ...string) *ValidatorInt32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt32LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

func (validator *ValidatorInt32P[T]) LessOrEqualTo(value T, template ...string) *ValidatorInt32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt32LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of a number is in a range (inclusive).
// For example:
//
//	Is(v.Int32(3).Between(2,6))
func (validator *ValidatorInt32P[T]) Between(min T, max T, template ...string) *ValidatorInt32P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt32Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

func (validator *ValidatorInt32P[T]) Zero(template ...string) *ValidatorInt32P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt32Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorInt32P[T]) ZeroOrNil(template ...string) *ValidatorInt32P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isInt32Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorInt32P[T]) Nil(template ...string) *ValidatorInt32P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

func (validator *ValidatorInt32P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorInt32P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

func (validator *ValidatorInt32P[T]) InSlice(slice []T, template ...string) *ValidatorInt32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt32InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}

func (validator *ValidatorInt32P[T]) Not() *ValidatorInt32P[T] {
	validator.context.Not()

	return validator
}



type ValidatorInt64P[T ~int64] struct {
	context *ValidatorContext
}

func Int64P[T ~int64](value *T, nameAndTitle ...string) *ValidatorInt64P[T] {
	return &ValidatorInt64P[T]{context: NewContext(value, nameAndTitle...)}
}

func (validator *ValidatorInt64P[T]) Context() *ValidatorContext {
	return validator.context
}

func (validator *ValidatorInt64P[T]) EqualTo(value T, template ...string) *ValidatorInt64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt64EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

func (validator *ValidatorInt64P[T]) GreaterThan(value T, template ...string) *ValidatorInt64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt64GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

func (validator *ValidatorInt64P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorInt64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt64GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

func (validator *ValidatorInt64P[T]) LessThan(value T, template ...string) *ValidatorInt64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt64LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

func (validator *ValidatorInt64P[T]) LessOrEqualTo(value T, template ...string) *ValidatorInt64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt64LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of a number is in a range (inclusive).
// For example:
//
//	Is(v.Int64(3).Between(2,6))
func (validator *ValidatorInt64P[T]) Between(min T, max T, template ...string) *ValidatorInt64P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt64Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

func (validator *ValidatorInt64P[T]) Zero(template ...string) *ValidatorInt64P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt64Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorInt64P[T]) ZeroOrNil(template ...string) *ValidatorInt64P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isInt64Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorInt64P[T]) Nil(template ...string) *ValidatorInt64P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

func (validator *ValidatorInt64P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorInt64P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

func (validator *ValidatorInt64P[T]) InSlice(slice []T, template ...string) *ValidatorInt64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt64InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}

func (validator *ValidatorInt64P[T]) Not() *ValidatorInt64P[T] {
	validator.context.Not()

	return validator
}



type ValidatorFloat32P[T ~float32] struct {
	context *ValidatorContext
}

func Float32P[T ~float32](value *T, nameAndTitle ...string) *ValidatorFloat32P[T] {
	return &ValidatorFloat32P[T]{context: NewContext(value, nameAndTitle...)}
}

func (validator *ValidatorFloat32P[T]) Context() *ValidatorContext {
	return validator.context
}

func (validator *ValidatorFloat32P[T]) EqualTo(value T, template ...string) *ValidatorFloat32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat32EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

func (validator *ValidatorFloat32P[T]) GreaterThan(value T, template ...string) *ValidatorFloat32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat32GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

func (validator *ValidatorFloat32P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorFloat32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat32GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

func (validator *ValidatorFloat32P[T]) LessThan(value T, template ...string) *ValidatorFloat32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat32LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

func (validator *ValidatorFloat32P[T]) LessOrEqualTo(value T, template ...string) *ValidatorFloat32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat32LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of a number is in a range (inclusive).
// For example:
//
//	Is(v.Float32(3).Between(2,6))
func (validator *ValidatorFloat32P[T]) Between(min T, max T, template ...string) *ValidatorFloat32P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat32Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

func (validator *ValidatorFloat32P[T]) Zero(template ...string) *ValidatorFloat32P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat32Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorFloat32P[T]) ZeroOrNil(template ...string) *ValidatorFloat32P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isFloat32Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorFloat32P[T]) Nil(template ...string) *ValidatorFloat32P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

func (validator *ValidatorFloat32P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorFloat32P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

func (validator *ValidatorFloat32P[T]) InSlice(slice []T, template ...string) *ValidatorFloat32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat32InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}

func (validator *ValidatorFloat32P[T]) Not() *ValidatorFloat32P[T] {
	validator.context.Not()

	return validator
}



type ValidatorFloat64P[T ~float64] struct {
	context *ValidatorContext
}

func Float64P[T ~float64](value *T, nameAndTitle ...string) *ValidatorFloat64P[T] {
	return &ValidatorFloat64P[T]{context: NewContext(value, nameAndTitle...)}
}

func (validator *ValidatorFloat64P[T]) Context() *ValidatorContext {
	return validator.context
}

func (validator *ValidatorFloat64P[T]) EqualTo(value T, template ...string) *ValidatorFloat64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat64EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

func (validator *ValidatorFloat64P[T]) GreaterThan(value T, template ...string) *ValidatorFloat64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat64GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

func (validator *ValidatorFloat64P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorFloat64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat64GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

func (validator *ValidatorFloat64P[T]) LessThan(value T, template ...string) *ValidatorFloat64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat64LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

func (validator *ValidatorFloat64P[T]) LessOrEqualTo(value T, template ...string) *ValidatorFloat64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat64LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of a number is in a range (inclusive).
// For example:
//
//	Is(v.Float64(3).Between(2,6))
func (validator *ValidatorFloat64P[T]) Between(min T, max T, template ...string) *ValidatorFloat64P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat64Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

func (validator *ValidatorFloat64P[T]) Zero(template ...string) *ValidatorFloat64P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat64Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorFloat64P[T]) ZeroOrNil(template ...string) *ValidatorFloat64P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isFloat64Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorFloat64P[T]) Nil(template ...string) *ValidatorFloat64P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

func (validator *ValidatorFloat64P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorFloat64P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

func (validator *ValidatorFloat64P[T]) InSlice(slice []T, template ...string) *ValidatorFloat64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat64InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}

func (validator *ValidatorFloat64P[T]) Not() *ValidatorFloat64P[T] {
	validator.context.Not()

	return validator
}



type ValidatorByteP[T ~byte] struct {
	context *ValidatorContext
}

func ByteP[T ~byte](value *T, nameAndTitle ...string) *ValidatorByteP[T] {
	return &ValidatorByteP[T]{context: NewContext(value, nameAndTitle...)}
}

func (validator *ValidatorByteP[T]) Context() *ValidatorContext {
	return validator.context
}

func (validator *ValidatorByteP[T]) EqualTo(value T, template ...string) *ValidatorByteP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isByteEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

func (validator *ValidatorByteP[T]) GreaterThan(value T, template ...string) *ValidatorByteP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isByteGreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

func (validator *ValidatorByteP[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorByteP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isByteGreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

func (validator *ValidatorByteP[T]) LessThan(value T, template ...string) *ValidatorByteP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isByteLessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

func (validator *ValidatorByteP[T]) LessOrEqualTo(value T, template ...string) *ValidatorByteP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isByteLessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of a number is in a range (inclusive).
// For example:
//
//	Is(v.Byte(3).Between(2,6))
func (validator *ValidatorByteP[T]) Between(min T, max T, template ...string) *ValidatorByteP[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isByteBetween(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

func (validator *ValidatorByteP[T]) Zero(template ...string) *ValidatorByteP[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isByteZero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorByteP[T]) ZeroOrNil(template ...string) *ValidatorByteP[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isByteZero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorByteP[T]) Nil(template ...string) *ValidatorByteP[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

func (validator *ValidatorByteP[T]) Passing(function func(v *T) bool, template ...string) *ValidatorByteP[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

func (validator *ValidatorByteP[T]) InSlice(slice []T, template ...string) *ValidatorByteP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isByteInSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}

func (validator *ValidatorByteP[T]) Not() *ValidatorByteP[T] {
	validator.context.Not()

	return validator
}



type ValidatorRuneP[T ~rune] struct {
	context *ValidatorContext
}

func RuneP[T ~rune](value *T, nameAndTitle ...string) *ValidatorRuneP[T] {
	return &ValidatorRuneP[T]{context: NewContext(value, nameAndTitle...)}
}

func (validator *ValidatorRuneP[T]) Context() *ValidatorContext {
	return validator.context
}

func (validator *ValidatorRuneP[T]) EqualTo(value T, template ...string) *ValidatorRuneP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isRuneEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

func (validator *ValidatorRuneP[T]) GreaterThan(value T, template ...string) *ValidatorRuneP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isRuneGreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

func (validator *ValidatorRuneP[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorRuneP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isRuneGreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

func (validator *ValidatorRuneP[T]) LessThan(value T, template ...string) *ValidatorRuneP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isRuneLessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

func (validator *ValidatorRuneP[T]) LessOrEqualTo(value T, template ...string) *ValidatorRuneP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isRuneLessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of a number is in a range (inclusive).
// For example:
//
//	Is(v.Rune(3).Between(2,6))
func (validator *ValidatorRuneP[T]) Between(min T, max T, template ...string) *ValidatorRuneP[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isRuneBetween(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

func (validator *ValidatorRuneP[T]) Zero(template ...string) *ValidatorRuneP[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isRuneZero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorRuneP[T]) ZeroOrNil(template ...string) *ValidatorRuneP[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isRuneZero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

func (validator *ValidatorRuneP[T]) Nil(template ...string) *ValidatorRuneP[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

func (validator *ValidatorRuneP[T]) Passing(function func(v *T) bool, template ...string) *ValidatorRuneP[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

func (validator *ValidatorRuneP[T]) InSlice(slice []T, template ...string) *ValidatorRuneP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isRuneInSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}

func (validator *ValidatorRuneP[T]) Not() *ValidatorRuneP[T] {
	validator.context.Not()

	return validator
}


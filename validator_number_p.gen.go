// Code generated by Valgo; DO NOT EDIT.

package valgo



// The uint8 pointer validator type that keeps its validator context.
type ValidatorUint8P[T ~uint8] struct {
	context *ValidatorContext
}

// Receives the uint8 pointer to validate.
//
// The value also can be a custom uint8 type such as `type Level *uint8;`
//
// Optionally, the function can receive a name and title, in that order,
// to be used in the error messages. A `value_%N“ pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Number`
func Uint8P[T ~uint8](value *T, nameAndTitle ...string) *ValidatorUint8P[T] {
	return &ValidatorUint8P[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorUint8P[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the boolean value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	n := uint8(0)
//	Is(v.Uint8P(&n).Not().Zero()).Valid()
func (validator *ValidatorUint8P[T]) Not() *ValidatorUint8P[T] {
	validator.context.Not()

	return validator
}

// Validate if the uint8 pointer value is equal to another value. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := uint8(2)
//	Is(v.Uint8P(quantity).Equal(uint8(2)))
func (validator *ValidatorUint8P[T]) EqualTo(value T, template ...string) *ValidatorUint8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint8EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the uint8 pointer value is greater than another value. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := uint8(3)
//	Is(v.Uint8P(&quantity).GreaterThan(uint8(2)))
func (validator *ValidatorUint8P[T]) GreaterThan(value T, template ...string) *ValidatorUint8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint8GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the uint8 pointer value is greater than or equal to another value. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := uint8(3)
//	Is(v.Uint8P(&quantity).GreaterOrEqualTo(uint8(3)))
func (validator *ValidatorUint8P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorUint8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint8GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the uint8 pointer value is less than another value. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := uint8(2)
//	Is(v.Uint8P(&quantity).LessThan(uint8(3)))
func (validator *ValidatorUint8P[T]) LessThan(value T, template ...string) *ValidatorUint8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint8LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the uint8 pointer value is less than or equal to another value. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := uint8(2)
//	Is(v.Uint8P(&quantity).LessOrEqualTo(uint8(2)))
func (validator *ValidatorUint8P[T]) LessOrEqualTo(value T, template ...string) *ValidatorUint8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint8LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of the uint8 pointer is within a range (inclusive).
// For example:
//
//	n := uint8(3)
//	Is(v.Uint8P(&n).Between(uint8(2),uint8(6)))
func (validator *ValidatorUint8P[T]) Between(min T, max T, template ...string) *ValidatorUint8P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint8Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the uint8 pointer value is zero.
//
// For example:
//
//	n := uint8(0)
//	Is(v.Uint8P(&n).Zero())
func (validator *ValidatorUint8P[T]) Zero(template ...string) *ValidatorUint8P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint8Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the uint8 pointer value is zero or nil.
//
// For example:
//
//	var _quantity *uint8
//	Is(v.Uint8P(_quantity).ZeroOrNil()) // Will be true
func (validator *ValidatorUint8P[T]) ZeroOrNil(template ...string) *ValidatorUint8P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isUint8Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the uint8 pointer value is nil.
//
// For example:
//
//	var quantity *uint8
//	Is(v.Uint8P(quantity).Nil()) // Will be true
func (validator *ValidatorUint8P[T]) Nil(template ...string) *ValidatorUint8P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

// Validate if the uint8 pointer value passes a custom function.
// For example:
//
//	quantity := uint8(2)
//	Is(v.Uint8P(&quantity).Passing((v *uint8) bool {
//		return *v == getAllowedQuantity()
//	})
func (validator *ValidatorUint8P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorUint8P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the uint8 pointer value is present in a numeric slice.
// For example:
//
//	quantity := uint8(3)
//	validQuantities := []uint8{1,3,5}
//	Is(v.Uint8P(&quantity).InSlice(validQuantities))
func (validator *ValidatorUint8P[T]) InSlice(slice []T, template ...string) *ValidatorUint8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint8InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}



// The uint16 pointer validator type that keeps its validator context.
type ValidatorUint16P[T ~uint16] struct {
	context *ValidatorContext
}

// Receives the uint16 pointer to validate.
//
// The value also can be a custom uint16 type such as `type Level *uint16;`
//
// Optionally, the function can receive a name and title, in that order,
// to be used in the error messages. A `value_%N“ pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Number`
func Uint16P[T ~uint16](value *T, nameAndTitle ...string) *ValidatorUint16P[T] {
	return &ValidatorUint16P[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorUint16P[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the boolean value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	n := uint16(0)
//	Is(v.Uint16P(&n).Not().Zero()).Valid()
func (validator *ValidatorUint16P[T]) Not() *ValidatorUint16P[T] {
	validator.context.Not()

	return validator
}

// Validate if the uint16 pointer value is equal to another value. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := uint16(2)
//	Is(v.Uint16P(quantity).Equal(uint16(2)))
func (validator *ValidatorUint16P[T]) EqualTo(value T, template ...string) *ValidatorUint16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint16EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the uint16 pointer value is greater than another value. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := uint16(3)
//	Is(v.Uint16P(&quantity).GreaterThan(uint16(2)))
func (validator *ValidatorUint16P[T]) GreaterThan(value T, template ...string) *ValidatorUint16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint16GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the uint16 pointer value is greater than or equal to another value. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := uint16(3)
//	Is(v.Uint16P(&quantity).GreaterOrEqualTo(uint16(3)))
func (validator *ValidatorUint16P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorUint16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint16GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the uint16 pointer value is less than another value. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := uint16(2)
//	Is(v.Uint16P(&quantity).LessThan(uint16(3)))
func (validator *ValidatorUint16P[T]) LessThan(value T, template ...string) *ValidatorUint16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint16LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the uint16 pointer value is less than or equal to another value. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := uint16(2)
//	Is(v.Uint16P(&quantity).LessOrEqualTo(uint16(2)))
func (validator *ValidatorUint16P[T]) LessOrEqualTo(value T, template ...string) *ValidatorUint16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint16LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of the uint16 pointer is within a range (inclusive).
// For example:
//
//	n := uint16(3)
//	Is(v.Uint16P(&n).Between(uint16(2),uint16(6)))
func (validator *ValidatorUint16P[T]) Between(min T, max T, template ...string) *ValidatorUint16P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint16Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the uint16 pointer value is zero.
//
// For example:
//
//	n := uint16(0)
//	Is(v.Uint16P(&n).Zero())
func (validator *ValidatorUint16P[T]) Zero(template ...string) *ValidatorUint16P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint16Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the uint16 pointer value is zero or nil.
//
// For example:
//
//	var _quantity *uint16
//	Is(v.Uint16P(_quantity).ZeroOrNil()) // Will be true
func (validator *ValidatorUint16P[T]) ZeroOrNil(template ...string) *ValidatorUint16P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isUint16Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the uint16 pointer value is nil.
//
// For example:
//
//	var quantity *uint16
//	Is(v.Uint16P(quantity).Nil()) // Will be true
func (validator *ValidatorUint16P[T]) Nil(template ...string) *ValidatorUint16P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

// Validate if the uint16 pointer value passes a custom function.
// For example:
//
//	quantity := uint16(2)
//	Is(v.Uint16P(&quantity).Passing((v *uint16) bool {
//		return *v == getAllowedQuantity()
//	})
func (validator *ValidatorUint16P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorUint16P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the uint16 pointer value is present in a numeric slice.
// For example:
//
//	quantity := uint16(3)
//	validQuantities := []uint16{1,3,5}
//	Is(v.Uint16P(&quantity).InSlice(validQuantities))
func (validator *ValidatorUint16P[T]) InSlice(slice []T, template ...string) *ValidatorUint16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint16InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}



// The uint32 pointer validator type that keeps its validator context.
type ValidatorUint32P[T ~uint32] struct {
	context *ValidatorContext
}

// Receives the uint32 pointer to validate.
//
// The value also can be a custom uint32 type such as `type Level *uint32;`
//
// Optionally, the function can receive a name and title, in that order,
// to be used in the error messages. A `value_%N“ pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Number`
func Uint32P[T ~uint32](value *T, nameAndTitle ...string) *ValidatorUint32P[T] {
	return &ValidatorUint32P[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorUint32P[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the boolean value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	n := uint32(0)
//	Is(v.Uint32P(&n).Not().Zero()).Valid()
func (validator *ValidatorUint32P[T]) Not() *ValidatorUint32P[T] {
	validator.context.Not()

	return validator
}

// Validate if the uint32 pointer value is equal to another value. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := uint32(2)
//	Is(v.Uint32P(quantity).Equal(uint32(2)))
func (validator *ValidatorUint32P[T]) EqualTo(value T, template ...string) *ValidatorUint32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint32EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the uint32 pointer value is greater than another value. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := uint32(3)
//	Is(v.Uint32P(&quantity).GreaterThan(uint32(2)))
func (validator *ValidatorUint32P[T]) GreaterThan(value T, template ...string) *ValidatorUint32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint32GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the uint32 pointer value is greater than or equal to another value. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := uint32(3)
//	Is(v.Uint32P(&quantity).GreaterOrEqualTo(uint32(3)))
func (validator *ValidatorUint32P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorUint32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint32GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the uint32 pointer value is less than another value. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := uint32(2)
//	Is(v.Uint32P(&quantity).LessThan(uint32(3)))
func (validator *ValidatorUint32P[T]) LessThan(value T, template ...string) *ValidatorUint32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint32LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the uint32 pointer value is less than or equal to another value. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := uint32(2)
//	Is(v.Uint32P(&quantity).LessOrEqualTo(uint32(2)))
func (validator *ValidatorUint32P[T]) LessOrEqualTo(value T, template ...string) *ValidatorUint32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint32LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of the uint32 pointer is within a range (inclusive).
// For example:
//
//	n := uint32(3)
//	Is(v.Uint32P(&n).Between(uint32(2),uint32(6)))
func (validator *ValidatorUint32P[T]) Between(min T, max T, template ...string) *ValidatorUint32P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint32Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the uint32 pointer value is zero.
//
// For example:
//
//	n := uint32(0)
//	Is(v.Uint32P(&n).Zero())
func (validator *ValidatorUint32P[T]) Zero(template ...string) *ValidatorUint32P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint32Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the uint32 pointer value is zero or nil.
//
// For example:
//
//	var _quantity *uint32
//	Is(v.Uint32P(_quantity).ZeroOrNil()) // Will be true
func (validator *ValidatorUint32P[T]) ZeroOrNil(template ...string) *ValidatorUint32P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isUint32Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the uint32 pointer value is nil.
//
// For example:
//
//	var quantity *uint32
//	Is(v.Uint32P(quantity).Nil()) // Will be true
func (validator *ValidatorUint32P[T]) Nil(template ...string) *ValidatorUint32P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

// Validate if the uint32 pointer value passes a custom function.
// For example:
//
//	quantity := uint32(2)
//	Is(v.Uint32P(&quantity).Passing((v *uint32) bool {
//		return *v == getAllowedQuantity()
//	})
func (validator *ValidatorUint32P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorUint32P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the uint32 pointer value is present in a numeric slice.
// For example:
//
//	quantity := uint32(3)
//	validQuantities := []uint32{1,3,5}
//	Is(v.Uint32P(&quantity).InSlice(validQuantities))
func (validator *ValidatorUint32P[T]) InSlice(slice []T, template ...string) *ValidatorUint32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint32InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}



// The uint64 pointer validator type that keeps its validator context.
type ValidatorUint64P[T ~uint64] struct {
	context *ValidatorContext
}

// Receives the uint64 pointer to validate.
//
// The value also can be a custom uint64 type such as `type Level *uint64;`
//
// Optionally, the function can receive a name and title, in that order,
// to be used in the error messages. A `value_%N“ pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Number`
func Uint64P[T ~uint64](value *T, nameAndTitle ...string) *ValidatorUint64P[T] {
	return &ValidatorUint64P[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorUint64P[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the boolean value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	n := uint64(0)
//	Is(v.Uint64P(&n).Not().Zero()).Valid()
func (validator *ValidatorUint64P[T]) Not() *ValidatorUint64P[T] {
	validator.context.Not()

	return validator
}

// Validate if the uint64 pointer value is equal to another value. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := uint64(2)
//	Is(v.Uint64P(quantity).Equal(uint64(2)))
func (validator *ValidatorUint64P[T]) EqualTo(value T, template ...string) *ValidatorUint64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint64EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the uint64 pointer value is greater than another value. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := uint64(3)
//	Is(v.Uint64P(&quantity).GreaterThan(uint64(2)))
func (validator *ValidatorUint64P[T]) GreaterThan(value T, template ...string) *ValidatorUint64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint64GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the uint64 pointer value is greater than or equal to another value. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := uint64(3)
//	Is(v.Uint64P(&quantity).GreaterOrEqualTo(uint64(3)))
func (validator *ValidatorUint64P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorUint64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint64GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the uint64 pointer value is less than another value. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := uint64(2)
//	Is(v.Uint64P(&quantity).LessThan(uint64(3)))
func (validator *ValidatorUint64P[T]) LessThan(value T, template ...string) *ValidatorUint64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint64LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the uint64 pointer value is less than or equal to another value. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := uint64(2)
//	Is(v.Uint64P(&quantity).LessOrEqualTo(uint64(2)))
func (validator *ValidatorUint64P[T]) LessOrEqualTo(value T, template ...string) *ValidatorUint64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint64LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of the uint64 pointer is within a range (inclusive).
// For example:
//
//	n := uint64(3)
//	Is(v.Uint64P(&n).Between(uint64(2),uint64(6)))
func (validator *ValidatorUint64P[T]) Between(min T, max T, template ...string) *ValidatorUint64P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint64Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the uint64 pointer value is zero.
//
// For example:
//
//	n := uint64(0)
//	Is(v.Uint64P(&n).Zero())
func (validator *ValidatorUint64P[T]) Zero(template ...string) *ValidatorUint64P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint64Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the uint64 pointer value is zero or nil.
//
// For example:
//
//	var _quantity *uint64
//	Is(v.Uint64P(_quantity).ZeroOrNil()) // Will be true
func (validator *ValidatorUint64P[T]) ZeroOrNil(template ...string) *ValidatorUint64P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isUint64Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the uint64 pointer value is nil.
//
// For example:
//
//	var quantity *uint64
//	Is(v.Uint64P(quantity).Nil()) // Will be true
func (validator *ValidatorUint64P[T]) Nil(template ...string) *ValidatorUint64P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

// Validate if the uint64 pointer value passes a custom function.
// For example:
//
//	quantity := uint64(2)
//	Is(v.Uint64P(&quantity).Passing((v *uint64) bool {
//		return *v == getAllowedQuantity()
//	})
func (validator *ValidatorUint64P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorUint64P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the uint64 pointer value is present in a numeric slice.
// For example:
//
//	quantity := uint64(3)
//	validQuantities := []uint64{1,3,5}
//	Is(v.Uint64P(&quantity).InSlice(validQuantities))
func (validator *ValidatorUint64P[T]) InSlice(slice []T, template ...string) *ValidatorUint64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isUint64InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}



// The int pointer validator type that keeps its validator context.
type ValidatorIntP[T ~int] struct {
	context *ValidatorContext
}

// Receives the int pointer to validate.
//
// The value also can be a custom int type such as `type Level *int;`
//
// Optionally, the function can receive a name and title, in that order,
// to be used in the error messages. A `value_%N“ pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Number`
func IntP[T ~int](value *T, nameAndTitle ...string) *ValidatorIntP[T] {
	return &ValidatorIntP[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorIntP[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the boolean value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	n := int(0)
//	Is(v.IntP(&n).Not().Zero()).Valid()
func (validator *ValidatorIntP[T]) Not() *ValidatorIntP[T] {
	validator.context.Not()

	return validator
}

// Validate if the int pointer value is equal to another value. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := int(2)
//	Is(v.IntP(quantity).Equal(int(2)))
func (validator *ValidatorIntP[T]) EqualTo(value T, template ...string) *ValidatorIntP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isIntEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the int pointer value is greater than another value. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := int(3)
//	Is(v.IntP(&quantity).GreaterThan(int(2)))
func (validator *ValidatorIntP[T]) GreaterThan(value T, template ...string) *ValidatorIntP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isIntGreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the int pointer value is greater than or equal to another value. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := int(3)
//	Is(v.IntP(&quantity).GreaterOrEqualTo(int(3)))
func (validator *ValidatorIntP[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorIntP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isIntGreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the int pointer value is less than another value. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := int(2)
//	Is(v.IntP(&quantity).LessThan(int(3)))
func (validator *ValidatorIntP[T]) LessThan(value T, template ...string) *ValidatorIntP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isIntLessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the int pointer value is less than or equal to another value. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := int(2)
//	Is(v.IntP(&quantity).LessOrEqualTo(int(2)))
func (validator *ValidatorIntP[T]) LessOrEqualTo(value T, template ...string) *ValidatorIntP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isIntLessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of the int pointer is within a range (inclusive).
// For example:
//
//	n := int(3)
//	Is(v.IntP(&n).Between(int(2),int(6)))
func (validator *ValidatorIntP[T]) Between(min T, max T, template ...string) *ValidatorIntP[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isIntBetween(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the int pointer value is zero.
//
// For example:
//
//	n := int(0)
//	Is(v.IntP(&n).Zero())
func (validator *ValidatorIntP[T]) Zero(template ...string) *ValidatorIntP[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isIntZero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the int pointer value is zero or nil.
//
// For example:
//
//	var _quantity *int
//	Is(v.IntP(_quantity).ZeroOrNil()) // Will be true
func (validator *ValidatorIntP[T]) ZeroOrNil(template ...string) *ValidatorIntP[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isIntZero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the int pointer value is nil.
//
// For example:
//
//	var quantity *int
//	Is(v.IntP(quantity).Nil()) // Will be true
func (validator *ValidatorIntP[T]) Nil(template ...string) *ValidatorIntP[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

// Validate if the int pointer value passes a custom function.
// For example:
//
//	quantity := int(2)
//	Is(v.IntP(&quantity).Passing((v *int) bool {
//		return *v == getAllowedQuantity()
//	})
func (validator *ValidatorIntP[T]) Passing(function func(v *T) bool, template ...string) *ValidatorIntP[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the int pointer value is present in a numeric slice.
// For example:
//
//	quantity := int(3)
//	validQuantities := []int{1,3,5}
//	Is(v.IntP(&quantity).InSlice(validQuantities))
func (validator *ValidatorIntP[T]) InSlice(slice []T, template ...string) *ValidatorIntP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isIntInSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}



// The int8 pointer validator type that keeps its validator context.
type ValidatorInt8P[T ~int8] struct {
	context *ValidatorContext
}

// Receives the int8 pointer to validate.
//
// The value also can be a custom int8 type such as `type Level *int8;`
//
// Optionally, the function can receive a name and title, in that order,
// to be used in the error messages. A `value_%N“ pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Number`
func Int8P[T ~int8](value *T, nameAndTitle ...string) *ValidatorInt8P[T] {
	return &ValidatorInt8P[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorInt8P[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the boolean value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	n := int8(0)
//	Is(v.Int8P(&n).Not().Zero()).Valid()
func (validator *ValidatorInt8P[T]) Not() *ValidatorInt8P[T] {
	validator.context.Not()

	return validator
}

// Validate if the int8 pointer value is equal to another value. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := int8(2)
//	Is(v.Int8P(quantity).Equal(int8(2)))
func (validator *ValidatorInt8P[T]) EqualTo(value T, template ...string) *ValidatorInt8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt8EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the int8 pointer value is greater than another value. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := int8(3)
//	Is(v.Int8P(&quantity).GreaterThan(int8(2)))
func (validator *ValidatorInt8P[T]) GreaterThan(value T, template ...string) *ValidatorInt8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt8GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the int8 pointer value is greater than or equal to another value. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := int8(3)
//	Is(v.Int8P(&quantity).GreaterOrEqualTo(int8(3)))
func (validator *ValidatorInt8P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorInt8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt8GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the int8 pointer value is less than another value. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := int8(2)
//	Is(v.Int8P(&quantity).LessThan(int8(3)))
func (validator *ValidatorInt8P[T]) LessThan(value T, template ...string) *ValidatorInt8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt8LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the int8 pointer value is less than or equal to another value. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := int8(2)
//	Is(v.Int8P(&quantity).LessOrEqualTo(int8(2)))
func (validator *ValidatorInt8P[T]) LessOrEqualTo(value T, template ...string) *ValidatorInt8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt8LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of the int8 pointer is within a range (inclusive).
// For example:
//
//	n := int8(3)
//	Is(v.Int8P(&n).Between(int8(2),int8(6)))
func (validator *ValidatorInt8P[T]) Between(min T, max T, template ...string) *ValidatorInt8P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt8Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the int8 pointer value is zero.
//
// For example:
//
//	n := int8(0)
//	Is(v.Int8P(&n).Zero())
func (validator *ValidatorInt8P[T]) Zero(template ...string) *ValidatorInt8P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt8Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the int8 pointer value is zero or nil.
//
// For example:
//
//	var _quantity *int8
//	Is(v.Int8P(_quantity).ZeroOrNil()) // Will be true
func (validator *ValidatorInt8P[T]) ZeroOrNil(template ...string) *ValidatorInt8P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isInt8Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the int8 pointer value is nil.
//
// For example:
//
//	var quantity *int8
//	Is(v.Int8P(quantity).Nil()) // Will be true
func (validator *ValidatorInt8P[T]) Nil(template ...string) *ValidatorInt8P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

// Validate if the int8 pointer value passes a custom function.
// For example:
//
//	quantity := int8(2)
//	Is(v.Int8P(&quantity).Passing((v *int8) bool {
//		return *v == getAllowedQuantity()
//	})
func (validator *ValidatorInt8P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorInt8P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the int8 pointer value is present in a numeric slice.
// For example:
//
//	quantity := int8(3)
//	validQuantities := []int8{1,3,5}
//	Is(v.Int8P(&quantity).InSlice(validQuantities))
func (validator *ValidatorInt8P[T]) InSlice(slice []T, template ...string) *ValidatorInt8P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt8InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}



// The int16 pointer validator type that keeps its validator context.
type ValidatorInt16P[T ~int16] struct {
	context *ValidatorContext
}

// Receives the int16 pointer to validate.
//
// The value also can be a custom int16 type such as `type Level *int16;`
//
// Optionally, the function can receive a name and title, in that order,
// to be used in the error messages. A `value_%N“ pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Number`
func Int16P[T ~int16](value *T, nameAndTitle ...string) *ValidatorInt16P[T] {
	return &ValidatorInt16P[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorInt16P[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the boolean value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	n := int16(0)
//	Is(v.Int16P(&n).Not().Zero()).Valid()
func (validator *ValidatorInt16P[T]) Not() *ValidatorInt16P[T] {
	validator.context.Not()

	return validator
}

// Validate if the int16 pointer value is equal to another value. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := int16(2)
//	Is(v.Int16P(quantity).Equal(int16(2)))
func (validator *ValidatorInt16P[T]) EqualTo(value T, template ...string) *ValidatorInt16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt16EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the int16 pointer value is greater than another value. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := int16(3)
//	Is(v.Int16P(&quantity).GreaterThan(int16(2)))
func (validator *ValidatorInt16P[T]) GreaterThan(value T, template ...string) *ValidatorInt16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt16GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the int16 pointer value is greater than or equal to another value. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := int16(3)
//	Is(v.Int16P(&quantity).GreaterOrEqualTo(int16(3)))
func (validator *ValidatorInt16P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorInt16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt16GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the int16 pointer value is less than another value. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := int16(2)
//	Is(v.Int16P(&quantity).LessThan(int16(3)))
func (validator *ValidatorInt16P[T]) LessThan(value T, template ...string) *ValidatorInt16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt16LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the int16 pointer value is less than or equal to another value. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := int16(2)
//	Is(v.Int16P(&quantity).LessOrEqualTo(int16(2)))
func (validator *ValidatorInt16P[T]) LessOrEqualTo(value T, template ...string) *ValidatorInt16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt16LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of the int16 pointer is within a range (inclusive).
// For example:
//
//	n := int16(3)
//	Is(v.Int16P(&n).Between(int16(2),int16(6)))
func (validator *ValidatorInt16P[T]) Between(min T, max T, template ...string) *ValidatorInt16P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt16Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the int16 pointer value is zero.
//
// For example:
//
//	n := int16(0)
//	Is(v.Int16P(&n).Zero())
func (validator *ValidatorInt16P[T]) Zero(template ...string) *ValidatorInt16P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt16Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the int16 pointer value is zero or nil.
//
// For example:
//
//	var _quantity *int16
//	Is(v.Int16P(_quantity).ZeroOrNil()) // Will be true
func (validator *ValidatorInt16P[T]) ZeroOrNil(template ...string) *ValidatorInt16P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isInt16Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the int16 pointer value is nil.
//
// For example:
//
//	var quantity *int16
//	Is(v.Int16P(quantity).Nil()) // Will be true
func (validator *ValidatorInt16P[T]) Nil(template ...string) *ValidatorInt16P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

// Validate if the int16 pointer value passes a custom function.
// For example:
//
//	quantity := int16(2)
//	Is(v.Int16P(&quantity).Passing((v *int16) bool {
//		return *v == getAllowedQuantity()
//	})
func (validator *ValidatorInt16P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorInt16P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the int16 pointer value is present in a numeric slice.
// For example:
//
//	quantity := int16(3)
//	validQuantities := []int16{1,3,5}
//	Is(v.Int16P(&quantity).InSlice(validQuantities))
func (validator *ValidatorInt16P[T]) InSlice(slice []T, template ...string) *ValidatorInt16P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt16InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}



// The int32 pointer validator type that keeps its validator context.
type ValidatorInt32P[T ~int32] struct {
	context *ValidatorContext
}

// Receives the int32 pointer to validate.
//
// The value also can be a custom int32 type such as `type Level *int32;`
//
// Optionally, the function can receive a name and title, in that order,
// to be used in the error messages. A `value_%N“ pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Number`
func Int32P[T ~int32](value *T, nameAndTitle ...string) *ValidatorInt32P[T] {
	return &ValidatorInt32P[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorInt32P[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the boolean value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	n := int32(0)
//	Is(v.Int32P(&n).Not().Zero()).Valid()
func (validator *ValidatorInt32P[T]) Not() *ValidatorInt32P[T] {
	validator.context.Not()

	return validator
}

// Validate if the int32 pointer value is equal to another value. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := int32(2)
//	Is(v.Int32P(quantity).Equal(int32(2)))
func (validator *ValidatorInt32P[T]) EqualTo(value T, template ...string) *ValidatorInt32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt32EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the int32 pointer value is greater than another value. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := int32(3)
//	Is(v.Int32P(&quantity).GreaterThan(int32(2)))
func (validator *ValidatorInt32P[T]) GreaterThan(value T, template ...string) *ValidatorInt32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt32GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the int32 pointer value is greater than or equal to another value. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := int32(3)
//	Is(v.Int32P(&quantity).GreaterOrEqualTo(int32(3)))
func (validator *ValidatorInt32P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorInt32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt32GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the int32 pointer value is less than another value. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := int32(2)
//	Is(v.Int32P(&quantity).LessThan(int32(3)))
func (validator *ValidatorInt32P[T]) LessThan(value T, template ...string) *ValidatorInt32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt32LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the int32 pointer value is less than or equal to another value. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := int32(2)
//	Is(v.Int32P(&quantity).LessOrEqualTo(int32(2)))
func (validator *ValidatorInt32P[T]) LessOrEqualTo(value T, template ...string) *ValidatorInt32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt32LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of the int32 pointer is within a range (inclusive).
// For example:
//
//	n := int32(3)
//	Is(v.Int32P(&n).Between(int32(2),int32(6)))
func (validator *ValidatorInt32P[T]) Between(min T, max T, template ...string) *ValidatorInt32P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt32Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the int32 pointer value is zero.
//
// For example:
//
//	n := int32(0)
//	Is(v.Int32P(&n).Zero())
func (validator *ValidatorInt32P[T]) Zero(template ...string) *ValidatorInt32P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt32Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the int32 pointer value is zero or nil.
//
// For example:
//
//	var _quantity *int32
//	Is(v.Int32P(_quantity).ZeroOrNil()) // Will be true
func (validator *ValidatorInt32P[T]) ZeroOrNil(template ...string) *ValidatorInt32P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isInt32Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the int32 pointer value is nil.
//
// For example:
//
//	var quantity *int32
//	Is(v.Int32P(quantity).Nil()) // Will be true
func (validator *ValidatorInt32P[T]) Nil(template ...string) *ValidatorInt32P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

// Validate if the int32 pointer value passes a custom function.
// For example:
//
//	quantity := int32(2)
//	Is(v.Int32P(&quantity).Passing((v *int32) bool {
//		return *v == getAllowedQuantity()
//	})
func (validator *ValidatorInt32P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorInt32P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the int32 pointer value is present in a numeric slice.
// For example:
//
//	quantity := int32(3)
//	validQuantities := []int32{1,3,5}
//	Is(v.Int32P(&quantity).InSlice(validQuantities))
func (validator *ValidatorInt32P[T]) InSlice(slice []T, template ...string) *ValidatorInt32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt32InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}



// The int64 pointer validator type that keeps its validator context.
type ValidatorInt64P[T ~int64] struct {
	context *ValidatorContext
}

// Receives the int64 pointer to validate.
//
// The value also can be a custom int64 type such as `type Level *int64;`
//
// Optionally, the function can receive a name and title, in that order,
// to be used in the error messages. A `value_%N“ pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Number`
func Int64P[T ~int64](value *T, nameAndTitle ...string) *ValidatorInt64P[T] {
	return &ValidatorInt64P[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorInt64P[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the boolean value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	n := int64(0)
//	Is(v.Int64P(&n).Not().Zero()).Valid()
func (validator *ValidatorInt64P[T]) Not() *ValidatorInt64P[T] {
	validator.context.Not()

	return validator
}

// Validate if the int64 pointer value is equal to another value. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := int64(2)
//	Is(v.Int64P(quantity).Equal(int64(2)))
func (validator *ValidatorInt64P[T]) EqualTo(value T, template ...string) *ValidatorInt64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt64EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the int64 pointer value is greater than another value. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := int64(3)
//	Is(v.Int64P(&quantity).GreaterThan(int64(2)))
func (validator *ValidatorInt64P[T]) GreaterThan(value T, template ...string) *ValidatorInt64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt64GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the int64 pointer value is greater than or equal to another value. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := int64(3)
//	Is(v.Int64P(&quantity).GreaterOrEqualTo(int64(3)))
func (validator *ValidatorInt64P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorInt64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt64GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the int64 pointer value is less than another value. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := int64(2)
//	Is(v.Int64P(&quantity).LessThan(int64(3)))
func (validator *ValidatorInt64P[T]) LessThan(value T, template ...string) *ValidatorInt64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt64LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the int64 pointer value is less than or equal to another value. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := int64(2)
//	Is(v.Int64P(&quantity).LessOrEqualTo(int64(2)))
func (validator *ValidatorInt64P[T]) LessOrEqualTo(value T, template ...string) *ValidatorInt64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt64LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of the int64 pointer is within a range (inclusive).
// For example:
//
//	n := int64(3)
//	Is(v.Int64P(&n).Between(int64(2),int64(6)))
func (validator *ValidatorInt64P[T]) Between(min T, max T, template ...string) *ValidatorInt64P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt64Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the int64 pointer value is zero.
//
// For example:
//
//	n := int64(0)
//	Is(v.Int64P(&n).Zero())
func (validator *ValidatorInt64P[T]) Zero(template ...string) *ValidatorInt64P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt64Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the int64 pointer value is zero or nil.
//
// For example:
//
//	var _quantity *int64
//	Is(v.Int64P(_quantity).ZeroOrNil()) // Will be true
func (validator *ValidatorInt64P[T]) ZeroOrNil(template ...string) *ValidatorInt64P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isInt64Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the int64 pointer value is nil.
//
// For example:
//
//	var quantity *int64
//	Is(v.Int64P(quantity).Nil()) // Will be true
func (validator *ValidatorInt64P[T]) Nil(template ...string) *ValidatorInt64P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

// Validate if the int64 pointer value passes a custom function.
// For example:
//
//	quantity := int64(2)
//	Is(v.Int64P(&quantity).Passing((v *int64) bool {
//		return *v == getAllowedQuantity()
//	})
func (validator *ValidatorInt64P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorInt64P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the int64 pointer value is present in a numeric slice.
// For example:
//
//	quantity := int64(3)
//	validQuantities := []int64{1,3,5}
//	Is(v.Int64P(&quantity).InSlice(validQuantities))
func (validator *ValidatorInt64P[T]) InSlice(slice []T, template ...string) *ValidatorInt64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isInt64InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}



// The float32 pointer validator type that keeps its validator context.
type ValidatorFloat32P[T ~float32] struct {
	context *ValidatorContext
}

// Receives the float32 pointer to validate.
//
// The value also can be a custom float32 type such as `type Level *float32;`
//
// Optionally, the function can receive a name and title, in that order,
// to be used in the error messages. A `value_%N“ pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Number`
func Float32P[T ~float32](value *T, nameAndTitle ...string) *ValidatorFloat32P[T] {
	return &ValidatorFloat32P[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorFloat32P[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the boolean value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	n := float32(0)
//	Is(v.Float32P(&n).Not().Zero()).Valid()
func (validator *ValidatorFloat32P[T]) Not() *ValidatorFloat32P[T] {
	validator.context.Not()

	return validator
}

// Validate if the float32 pointer value is equal to another value. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := float32(2)
//	Is(v.Float32P(quantity).Equal(float32(2)))
func (validator *ValidatorFloat32P[T]) EqualTo(value T, template ...string) *ValidatorFloat32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat32EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the float32 pointer value is greater than another value. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := float32(3)
//	Is(v.Float32P(&quantity).GreaterThan(float32(2)))
func (validator *ValidatorFloat32P[T]) GreaterThan(value T, template ...string) *ValidatorFloat32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat32GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the float32 pointer value is greater than or equal to another value. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := float32(3)
//	Is(v.Float32P(&quantity).GreaterOrEqualTo(float32(3)))
func (validator *ValidatorFloat32P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorFloat32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat32GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the float32 pointer value is less than another value. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := float32(2)
//	Is(v.Float32P(&quantity).LessThan(float32(3)))
func (validator *ValidatorFloat32P[T]) LessThan(value T, template ...string) *ValidatorFloat32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat32LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the float32 pointer value is less than or equal to another value. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := float32(2)
//	Is(v.Float32P(&quantity).LessOrEqualTo(float32(2)))
func (validator *ValidatorFloat32P[T]) LessOrEqualTo(value T, template ...string) *ValidatorFloat32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat32LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of the float32 pointer is within a range (inclusive).
// For example:
//
//	n := float32(3)
//	Is(v.Float32P(&n).Between(float32(2),float32(6)))
func (validator *ValidatorFloat32P[T]) Between(min T, max T, template ...string) *ValidatorFloat32P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat32Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the float32 pointer value is zero.
//
// For example:
//
//	n := float32(0)
//	Is(v.Float32P(&n).Zero())
func (validator *ValidatorFloat32P[T]) Zero(template ...string) *ValidatorFloat32P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat32Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the float32 pointer value is zero or nil.
//
// For example:
//
//	var _quantity *float32
//	Is(v.Float32P(_quantity).ZeroOrNil()) // Will be true
func (validator *ValidatorFloat32P[T]) ZeroOrNil(template ...string) *ValidatorFloat32P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isFloat32Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the float32 pointer value is nil.
//
// For example:
//
//	var quantity *float32
//	Is(v.Float32P(quantity).Nil()) // Will be true
func (validator *ValidatorFloat32P[T]) Nil(template ...string) *ValidatorFloat32P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

// Validate if the float32 pointer value passes a custom function.
// For example:
//
//	quantity := float32(2)
//	Is(v.Float32P(&quantity).Passing((v *float32) bool {
//		return *v == getAllowedQuantity()
//	})
func (validator *ValidatorFloat32P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorFloat32P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the float32 pointer value is present in a numeric slice.
// For example:
//
//	quantity := float32(3)
//	validQuantities := []float32{1,3,5}
//	Is(v.Float32P(&quantity).InSlice(validQuantities))
func (validator *ValidatorFloat32P[T]) InSlice(slice []T, template ...string) *ValidatorFloat32P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat32InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}



// The float64 pointer validator type that keeps its validator context.
type ValidatorFloat64P[T ~float64] struct {
	context *ValidatorContext
}

// Receives the float64 pointer to validate.
//
// The value also can be a custom float64 type such as `type Level *float64;`
//
// Optionally, the function can receive a name and title, in that order,
// to be used in the error messages. A `value_%N“ pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Number`
func Float64P[T ~float64](value *T, nameAndTitle ...string) *ValidatorFloat64P[T] {
	return &ValidatorFloat64P[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorFloat64P[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the boolean value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	n := float64(0)
//	Is(v.Float64P(&n).Not().Zero()).Valid()
func (validator *ValidatorFloat64P[T]) Not() *ValidatorFloat64P[T] {
	validator.context.Not()

	return validator
}

// Validate if the float64 pointer value is equal to another value. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := float64(2)
//	Is(v.Float64P(quantity).Equal(float64(2)))
func (validator *ValidatorFloat64P[T]) EqualTo(value T, template ...string) *ValidatorFloat64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat64EqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the float64 pointer value is greater than another value. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := float64(3)
//	Is(v.Float64P(&quantity).GreaterThan(float64(2)))
func (validator *ValidatorFloat64P[T]) GreaterThan(value T, template ...string) *ValidatorFloat64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat64GreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the float64 pointer value is greater than or equal to another value. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := float64(3)
//	Is(v.Float64P(&quantity).GreaterOrEqualTo(float64(3)))
func (validator *ValidatorFloat64P[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorFloat64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat64GreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the float64 pointer value is less than another value. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := float64(2)
//	Is(v.Float64P(&quantity).LessThan(float64(3)))
func (validator *ValidatorFloat64P[T]) LessThan(value T, template ...string) *ValidatorFloat64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat64LessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the float64 pointer value is less than or equal to another value. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := float64(2)
//	Is(v.Float64P(&quantity).LessOrEqualTo(float64(2)))
func (validator *ValidatorFloat64P[T]) LessOrEqualTo(value T, template ...string) *ValidatorFloat64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat64LessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of the float64 pointer is within a range (inclusive).
// For example:
//
//	n := float64(3)
//	Is(v.Float64P(&n).Between(float64(2),float64(6)))
func (validator *ValidatorFloat64P[T]) Between(min T, max T, template ...string) *ValidatorFloat64P[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat64Between(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the float64 pointer value is zero.
//
// For example:
//
//	n := float64(0)
//	Is(v.Float64P(&n).Zero())
func (validator *ValidatorFloat64P[T]) Zero(template ...string) *ValidatorFloat64P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat64Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the float64 pointer value is zero or nil.
//
// For example:
//
//	var _quantity *float64
//	Is(v.Float64P(_quantity).ZeroOrNil()) // Will be true
func (validator *ValidatorFloat64P[T]) ZeroOrNil(template ...string) *ValidatorFloat64P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isFloat64Zero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the float64 pointer value is nil.
//
// For example:
//
//	var quantity *float64
//	Is(v.Float64P(quantity).Nil()) // Will be true
func (validator *ValidatorFloat64P[T]) Nil(template ...string) *ValidatorFloat64P[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

// Validate if the float64 pointer value passes a custom function.
// For example:
//
//	quantity := float64(2)
//	Is(v.Float64P(&quantity).Passing((v *float64) bool {
//		return *v == getAllowedQuantity()
//	})
func (validator *ValidatorFloat64P[T]) Passing(function func(v *T) bool, template ...string) *ValidatorFloat64P[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the float64 pointer value is present in a numeric slice.
// For example:
//
//	quantity := float64(3)
//	validQuantities := []float64{1,3,5}
//	Is(v.Float64P(&quantity).InSlice(validQuantities))
func (validator *ValidatorFloat64P[T]) InSlice(slice []T, template ...string) *ValidatorFloat64P[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isFloat64InSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}



// The byte pointer validator type that keeps its validator context.
type ValidatorByteP[T ~byte] struct {
	context *ValidatorContext
}

// Receives the byte pointer to validate.
//
// The value also can be a custom byte type such as `type Level *byte;`
//
// Optionally, the function can receive a name and title, in that order,
// to be used in the error messages. A `value_%N“ pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Number`
func ByteP[T ~byte](value *T, nameAndTitle ...string) *ValidatorByteP[T] {
	return &ValidatorByteP[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorByteP[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the boolean value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	n := byte(0)
//	Is(v.ByteP(&n).Not().Zero()).Valid()
func (validator *ValidatorByteP[T]) Not() *ValidatorByteP[T] {
	validator.context.Not()

	return validator
}

// Validate if the byte pointer value is equal to another value. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := byte(2)
//	Is(v.ByteP(quantity).Equal(byte(2)))
func (validator *ValidatorByteP[T]) EqualTo(value T, template ...string) *ValidatorByteP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isByteEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the byte pointer value is greater than another value. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := byte(3)
//	Is(v.ByteP(&quantity).GreaterThan(byte(2)))
func (validator *ValidatorByteP[T]) GreaterThan(value T, template ...string) *ValidatorByteP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isByteGreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the byte pointer value is greater than or equal to another value. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := byte(3)
//	Is(v.ByteP(&quantity).GreaterOrEqualTo(byte(3)))
func (validator *ValidatorByteP[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorByteP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isByteGreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the byte pointer value is less than another value. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := byte(2)
//	Is(v.ByteP(&quantity).LessThan(byte(3)))
func (validator *ValidatorByteP[T]) LessThan(value T, template ...string) *ValidatorByteP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isByteLessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the byte pointer value is less than or equal to another value. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := byte(2)
//	Is(v.ByteP(&quantity).LessOrEqualTo(byte(2)))
func (validator *ValidatorByteP[T]) LessOrEqualTo(value T, template ...string) *ValidatorByteP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isByteLessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of the byte pointer is within a range (inclusive).
// For example:
//
//	n := byte(3)
//	Is(v.ByteP(&n).Between(byte(2),byte(6)))
func (validator *ValidatorByteP[T]) Between(min T, max T, template ...string) *ValidatorByteP[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isByteBetween(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the byte pointer value is zero.
//
// For example:
//
//	n := byte(0)
//	Is(v.ByteP(&n).Zero())
func (validator *ValidatorByteP[T]) Zero(template ...string) *ValidatorByteP[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isByteZero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the byte pointer value is zero or nil.
//
// For example:
//
//	var _quantity *byte
//	Is(v.ByteP(_quantity).ZeroOrNil()) // Will be true
func (validator *ValidatorByteP[T]) ZeroOrNil(template ...string) *ValidatorByteP[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isByteZero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the byte pointer value is nil.
//
// For example:
//
//	var quantity *byte
//	Is(v.ByteP(quantity).Nil()) // Will be true
func (validator *ValidatorByteP[T]) Nil(template ...string) *ValidatorByteP[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

// Validate if the byte pointer value passes a custom function.
// For example:
//
//	quantity := byte(2)
//	Is(v.ByteP(&quantity).Passing((v *byte) bool {
//		return *v == getAllowedQuantity()
//	})
func (validator *ValidatorByteP[T]) Passing(function func(v *T) bool, template ...string) *ValidatorByteP[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the byte pointer value is present in a numeric slice.
// For example:
//
//	quantity := byte(3)
//	validQuantities := []byte{1,3,5}
//	Is(v.ByteP(&quantity).InSlice(validQuantities))
func (validator *ValidatorByteP[T]) InSlice(slice []T, template ...string) *ValidatorByteP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isByteInSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}



// The rune pointer validator type that keeps its validator context.
type ValidatorRuneP[T ~rune] struct {
	context *ValidatorContext
}

// Receives the rune pointer to validate.
//
// The value also can be a custom rune type such as `type Level *rune;`
//
// Optionally, the function can receive a name and title, in that order,
// to be used in the error messages. A `value_%N“ pattern is used as a name in
// error messages if a name and title are not supplied; for example: value_0.
// When the name is provided but not the title, then the name is humanized to be
// used as the title as well; for example the name `phone_number` will be
// humanized as `Phone Number`
func RuneP[T ~rune](value *T, nameAndTitle ...string) *ValidatorRuneP[T] {
	return &ValidatorRuneP[T]{context: NewContext(value, nameAndTitle...)}
}

// Return the context of the validator. The context is useful to create a custom
// validator by extending this validator.
func (validator *ValidatorRuneP[T]) Context() *ValidatorContext {
	return validator.context
}

// Invert the boolean value associated with the next validator function.
// For example:
//
//	// It will return false because Not() inverts the boolean value associated with the Zero() function
//	n := rune(0)
//	Is(v.RuneP(&n).Not().Zero()).Valid()
func (validator *ValidatorRuneP[T]) Not() *ValidatorRuneP[T] {
	validator.context.Not()

	return validator
}

// Validate if the rune pointer value is equal to another value. This function internally uses
// the golang `==` operator.
// For example:
//
//	quantity := rune(2)
//	Is(v.RuneP(quantity).Equal(rune(2)))
func (validator *ValidatorRuneP[T]) EqualTo(value T, template ...string) *ValidatorRuneP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isRuneEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyEqualTo, value, template...)

	return validator
}

// Validate if the rune pointer value is greater than another value. This function internally
// uses the golang `>` operator.
// For example:
//
//	quantity := rune(3)
//	Is(v.RuneP(&quantity).GreaterThan(rune(2)))
func (validator *ValidatorRuneP[T]) GreaterThan(value T, template ...string) *ValidatorRuneP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isRuneGreaterThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterThan, value, template...)

	return validator
}

// Validate if the rune pointer value is greater than or equal to another value. This function
// internally uses the golang `>=` operator.
// For example:
//
//	quantity := rune(3)
//	Is(v.RuneP(&quantity).GreaterOrEqualTo(rune(3)))
func (validator *ValidatorRuneP[T]) GreaterOrEqualTo(value T, template ...string) *ValidatorRuneP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isRuneGreaterOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyGreaterOrEqualTo, value, template...)

	return validator
}

// Validate if the rune pointer value is less than another value. This function internally
// uses the golang `<` operator.
// For example:
//
//	quantity := rune(2)
//	Is(v.RuneP(&quantity).LessThan(rune(3)))
func (validator *ValidatorRuneP[T]) LessThan(value T, template ...string) *ValidatorRuneP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isRuneLessThan(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessThan, value, template...)

	return validator
}

// Validate if the rune pointer value is less than or equal to another value. This function
// internally uses the golang `<=` operator.
// For example:
//
//	quantity := rune(2)
//	Is(v.RuneP(&quantity).LessOrEqualTo(rune(2)))
func (validator *ValidatorRuneP[T]) LessOrEqualTo(value T, template ...string) *ValidatorRuneP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isRuneLessOrEqualTo(*(validator.context.Value().(*T)), value)
		},
		ErrorKeyLessOrEqualTo, value, template...)

	return validator
}

// Validate if the value of the rune pointer is within a range (inclusive).
// For example:
//
//	n := rune(3)
//	Is(v.RuneP(&n).Between(rune(2),rune(6)))
func (validator *ValidatorRuneP[T]) Between(min T, max T, template ...string) *ValidatorRuneP[T] {
	validator.context.AddWithParams(
		func() bool {
			return validator.context.Value().(*T) != nil && isRuneBetween(*(validator.context.Value().(*T)), min, max)
		},
		ErrorKeyBetween,
		map[string]any{"title": validator.context.title, "min": min, "max": max},
		template...)

	return validator
}

// Validate if the rune pointer value is zero.
//
// For example:
//
//	n := rune(0)
//	Is(v.RuneP(&n).Zero())
func (validator *ValidatorRuneP[T]) Zero(template ...string) *ValidatorRuneP[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) != nil && isRuneZero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the rune pointer value is zero or nil.
//
// For example:
//
//	var _quantity *rune
//	Is(v.RuneP(_quantity).ZeroOrNil()) // Will be true
func (validator *ValidatorRuneP[T]) ZeroOrNil(template ...string) *ValidatorRuneP[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil || isRuneZero(*(validator.context.Value().(*T)))
		},
		ErrorKeyZero, template...)

	return validator
}

// Validate if the rune pointer value is nil.
//
// For example:
//
//	var quantity *rune
//	Is(v.RuneP(quantity).Nil()) // Will be true
func (validator *ValidatorRuneP[T]) Nil(template ...string) *ValidatorRuneP[T] {
	validator.context.Add(
		func() bool {
			return validator.context.Value().(*T) == nil
		},
		ErrorKeyNil, template...)

	return validator
}

// Validate if the rune pointer value passes a custom function.
// For example:
//
//	quantity := rune(2)
//	Is(v.RuneP(&quantity).Passing((v *rune) bool {
//		return *v == getAllowedQuantity()
//	})
func (validator *ValidatorRuneP[T]) Passing(function func(v *T) bool, template ...string) *ValidatorRuneP[T] {
	validator.context.Add(
		func() bool {
			return function(validator.context.Value().(*T))
		},
		ErrorKeyPassing, template...)

	return validator
}

// Validate if the rune pointer value is present in a numeric slice.
// For example:
//
//	quantity := rune(3)
//	validQuantities := []rune{1,3,5}
//	Is(v.RuneP(&quantity).InSlice(validQuantities))
func (validator *ValidatorRuneP[T]) InSlice(slice []T, template ...string) *ValidatorRuneP[T] {
	validator.context.AddWithValue(
		func() bool {
			return validator.context.Value().(*T) != nil && isRuneInSlice(*(validator.context.Value().(*T)), slice)
		},
		ErrorKeyInSlice, validator.context.Value(), template...)

	return validator
}

